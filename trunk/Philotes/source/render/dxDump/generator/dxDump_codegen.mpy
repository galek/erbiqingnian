import sys
import string
from xml.dom import ext
from xml.dom.ext.reader import PyExpat
from xml.dom.NodeFilter import NodeFilter
from xml.dom import Node  

#
# TODO
# dump zbuffer
# dump stencil buffer
# D3DTSS_TEXCOORDINDEX
# html output (ms-help://MS.VSCC.2003/MS.DirectX9.1033/DirectX9_c/directx/graphics/reference/d3d/enums/d3drenderstatetype.htm#D3DRS_VERTEXBLEND), texturakra
# IntelliDump
#

# visszaadja a kapott node nev nevu gyereket 
def belep(node, nev):
	children=node.childNodes
	for a in children:
		if a.nodeName==nev and a.nodeType==Node.ELEMENT_NODE:
			return a

# kiirja a kapott node gyermekeit
def printchildren(node):
	children=node.childNodes
	for a in children:
		if a.nodeType==Node.ELEMENT_NODE:
			print a.nodeName,' ', a.nodeType,' ', a.nodeValue

# megmondja, hogy a kapott node tipus tipusu-e
def szur(node, tipus): return node.nodeName==tipus

def renderstate(node): return szur(node, "RenderState")
def value(node): return szur(node, "Value")
def samplerstate(node): return szur(node, "SamplerState")
def texturestage(node): return szur(node, "TextureStageState")
def istype(node): return szur(node, "Type")
def errorcode(node): return szur(node, "ErrorCode")

xmlfile="dx9RenderStates.xml"
typefile="dx9Types.xml"
errorfile="dx9ErrorCodes.xml"

# beolvassuk az XML file-t
print "Reading XML files...",
reader = PyExpat.Reader()
doc = reader.fromUri(xmlfile)
doc2 = reader.fromUri(typefile)
doc3 = reader.fromUri(errorfile)
print "OK"

f=open("dxdump.cpp", 'w') 

# belepunk oda, ahol az erdekes node-ok vannak
ndx9Dump=belep(doc, "dx9Dump") 
nRenderStates=belep(ndx9Dump, "RenderStates") 
nSamplerStates=belep(ndx9Dump, "SamplerStates") 
nTextureStages=belep(ndx9Dump, "TextureStageStates") 


dxtypes = {}
nTypes=belep(doc2, "dx9Types")
nlTypes = filter(istype, nTypes.childNodes)
for i in nlTypes:
	dxtypes[i.attributes[(None,"name")].nodeValue] = i

:beginning.cpp
.void dxDumpRenderStates(IDirect3DDevice9* p_pd3dDevice, void (*logger)(const char*)) {
.string msg;
.logger("================================ dxDumpRenderStates start ========================");
.logger("RenderStates");

nlRenderStates = filter(renderstate, nRenderStates.childNodes)
for i in nlRenderStates:
	rsname = i.attributes[(None,"name")].nodeValue
	_rsname = "_" + rsname
	addr_rsname = "&" + _rsname
	mytype = i.attributes[(None,"type")].nodeValue
	typenode = dxtypes[mytype]
	subtype = typenode.attributes[(None,"subtype")].nodeValue
	
	.
	.	msg = "\t";
	.	DWORD _$rsname$;
	.	p_pd3dDevice->GetRenderState($rsname$, $addr_rsname$);

	# ----------------- ENUM ----------------------
	if subtype == "ENUM":
		.	msg += "$rsname$ = ";
		.	switch($_rsname$) {
		nlValues = filter(value, typenode.childNodes)
		for j in nlValues:
			rsvalue = j.attributes[(None,"name")].nodeValue
			.		case $rsvalue$:
			.			msg += "$rsvalue$";
			.			break;
			
		.		default:
		.			msg += "?";
		.			break;
		.	}
		.	logger(msg.c_str());

	# ----------------- DWORD ----------------------
	if subtype == "DWORD":
		.	logDword(msg, "$rsname$", $_rsname$);
		.	logger(msg.c_str());

	# ----------------- int ----------------------
	if subtype == "INT":
		.	logInt(msg, "$rsname$", $_rsname$);
		.	logger(msg.c_str());

	# ----------------- float ----------------------
	if subtype == "FLOAT":
		.	logFloat(msg, "$rsname$", $_rsname$);
		.	logger(msg.c_str());

	# ----------------- BITFIELD ----------------------
	if subtype == "BITFIELD":
		.	msg += "$rsname$ =";
		nlValues = filter(value, typenode.childNodes)
		for j in nlValues:
			rsvalue = j.attributes[(None,"name")].nodeValue
			.	if ( $_rsname$ & $rsvalue$)
			.		msg += " $rsvalue$";
		.	logger(msg.c_str());
.
.logger("================================ dxDumpRenderStates end ========================");
.}
.
.

#---------TEXTURESTAGESTATES------------------------------------------------------------------------------------------------------


.void dxDumpTextureStageStates(IDirect3DDevice9* p_pd3dDevice, void (*logger)(const char*)) {
.string msg;
.logger("================================ dxDumpTextureStageStates start ========================");
.logger("TextureStageStates");
.if (!initialized) logger ("dxDump wasn't initialized! unable to dump texture stage states!");

nlTextureStages = filter(texturestage, nTextureStages.childNodes)

for i in nlTextureStages:
	tsname = i.attributes[(None,"name")].nodeValue
	.	DWORD _$tsname$;

.
.

.DWORD TSSNum = 0;
.int wasDisabled = 0;
.while (TSSNum < MaxTSSNum && !wasDisabled) {
.	char buf[1024];
.	sprintf(buf, "	TextureStage %d", TSSNum);
.	logger(buf);
for i in nlTextureStages:
	tsname = i.attributes[(None,"name")].nodeValue
	_tsname = "_" + tsname
	addr_tsname = "&" + _tsname
	mytype = i.attributes[(None,"type")].nodeValue
	typenode = dxtypes[i.attributes[(None,"type")].nodeValue]
	subtype = typenode.attributes[(None,"subtype")].nodeValue

	.
	.	msg = "\t\t";
	.	p_pd3dDevice->GetTextureStageState(TSSNum, $tsname$, $addr_tsname$);

	# ----------------- ENUM ----------------------
	if subtype == "ENUM":
		.	msg += "$tsname$ = ";
		.	switch($_tsname$) {
		nlValues = filter(value, typenode.childNodes)
		for j in nlValues:
			tsvalue = j.attributes[(None,"name")].nodeValue
			.		case $tsvalue$:
			.			msg += "$tsvalue$";
			.			break;
			
		.		default:
		.			msg += "?";
		.			break;
		.	}
		.	logger(msg.c_str());

	# ----------------- D3DTA ----------------------
	if subtype == "D3DTA":
		.	msg += "$tsname$ =";
		.	switch($_tsname$ & D3DTA_SELECTMASK) {
		nlValues = filter(value, typenode.childNodes)
		for j in nlValues:
			tsvalue = j.attributes[(None,"name")].nodeValue
			.		case $tsvalue$:
			.			msg += " $tsvalue$";
			.			break;
			
		.		default:
		.			msg += "?";
		.			break;
		.	}
		typenode = dxtypes["D3DTA_supp"]
		nlValues = filter(value, typenode.childNodes)
		for j in nlValues:
			tsvalue = j.attributes[(None,"name")].nodeValue
			.	if ($_tsname$ & $tsvalue$)
			.		msg += " $tsvalue$";				
		.	logger(msg.c_str());


	# ----------------- DWORD ----------------------
	if subtype == "DWORD":
		.	logDword(msg, "$tsname$", $_tsname$);
		.	logger(msg.c_str());

	# ----------------- int ----------------------
	if subtype == "INT":
		.	logInt(msg, "$tsname$", $_tsname$);
		.	logger(msg.c_str());

	# ----------------- float ----------------------
	if subtype == "FLOAT":
		.	logFloat(msg, "$tsname$", $_tsname$);
		.	logger(msg.c_str());

	# ----------------- BITFIELD ----------------------
	if subtype == "BITFIELD":
		.	msg += "$tsname$ =";
		nlValues = filter(value, i.childNodes)
		for j in nlValues:
			tsvalue = typenode.attributes[(None,"name")].nodeValue
			.	if ( $_tsname$ & $tsvalue$)
			.		msg += " $tsvalue$";
		.	logger(msg.c_str());
.
.	TSSNum++;
.	if ( (_D3DTSS_COLOROP == D3DTOP_DISABLE) && (_D3DTSS_ALPHAOP == D3DTOP_DISABLE) )
.		wasDisabled = 1;
.}
.logger("================================ dxDumpTextureStageStates end ========================");
.}
.
.

#---------SAMPLERSTATES------------------------------------------------------------------------------------------------------

.void dxDumpSamplerStates(IDirect3DDevice9* p_pd3dDevice, void (*logger)(const char*)) {
.string msg;
.logger("================================ dxDumpSamplerStates start ========================");
.logger("SamplerStates");
.if (!initialized) logger ("dxDump wasn't initialized! unable to dump sampler states!");

nlSamplerStates = filter(samplerstate, nSamplerStates.childNodes)

for i in nlSamplerStates:
	ssname = i.attributes[(None,"name")].nodeValue
	.	DWORD _$ssname$;

.
.

.DWORD samplerNum = 0;
.while (samplerNum < MaxTSSNum) {
.	char buf[1024];
.	sprintf(buf, "	Sampler %d", samplerNum);
.	logger(buf);
for i in nlSamplerStates:
	ssname = i.attributes[(None,"name")].nodeValue
	_ssname = "_" + ssname
	addr_ssname = "&" + _ssname
	mytype = i.attributes[(None,"type")].nodeValue
	typenode = dxtypes[mytype]
	subtype = typenode.attributes[(None,"subtype")].nodeValue

	.
	.	msg = "\t\t";
	.	p_pd3dDevice->GetSamplerState(samplerNum , $ssname$, $addr_ssname$);

	# ----------------- ENUM ----------------------
	if subtype == "ENUM":
		.	msg += "$ssname$ = ";
		.	switch($_ssname$) {
		nlValues = filter(value, typenode.childNodes)
		for j in nlValues:
			ssvalue = j.attributes[(None,"name")].nodeValue
			.		case $ssvalue$:
			.			msg += "$ssvalue$";
			.			break;
			
		.		default:
		.			msg += "?";
		.			break;
		.	}
		.	logger(msg.c_str());

	# ----------------- DWORD ----------------------
	if subtype == "DWORD":
		.	logDword(msg, "$ssname$", $_ssname$);
		.	logger(msg.c_str());

	# ----------------- int ----------------------
	if subtype == "INT":
		.	logInt(msg, "$ssname$", $_ssname$);
		.	logger(msg.c_str());

	# ----------------- float ----------------------
	if subtype == "FLOAT":
		.	logFloat(msg, "$ssname$", $_ssname$);
		.	logger(msg.c_str());
.samplerNum++;
.}
.logger("================================ dxDumpSamplerStates end ========================");
.}
.
.

ndx9ErrorCodes=belep(doc3, "dx9ErrorCodes") 
nlErrorCodes = filter(errorcode, ndx9ErrorCodes.childNodes)
.string dxError2Errname(HRESULT p_hr) {
.	switch (p_hr) {
for i in nlErrorCodes:
	errname = i.attributes[(None,"name")].nodeValue
	.		case $errname$: return "$errname$"; break;
.		default: return "?"; break;
.	}
.}
.string dxError2Explanation(HRESULT p_hr) {
.	switch (p_hr) {
for i in nlErrorCodes:
	errname = i.attributes[(None,"name")].nodeValue
	errexplanation = i.attributes[(None,"explanation")].nodeValue
	.		case $errname$: return "$errexplanation$"; break;
.		default: return "?"; break;
.	}
.}
.
:ending.cpp
f.close() 

print "Cleaning up...",
reader.releaseNode(doc)
reader.releaseNode(doc2)
reader.releaseNode(doc3)
print "OK"
