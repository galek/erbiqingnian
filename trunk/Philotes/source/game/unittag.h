//----------------------------------------------------------------------------
// unittag.h
//
// (C)Copyright 2003, Flagship Studios. All rights reserved.
//----------------------------------------------------------------------------
#ifndef _UNITTAG_H_
#define _UNITTAG_H_


//----------------------------------------------------------------------------
// INCLUDES
//----------------------------------------------------------------------------
#ifndef _GAME_H_
#error unittag.h requires game.h be included first
#endif

#ifndef _S_MESSAGE_H_
#include "s_message.h"
#endif


#include "../data_common/excel/tag_hdr.h"			// auto generated by quest.xls

//----------------------------------------------------------------------------
// ENUM
//----------------------------------------------------------------------------
enum TAG_CONSTANTS
{
	TAG_SELECTOR_HOTKEY_FIRST = TAG_SELECTOR_HOTKEY1,
	TAG_SELECTOR_LAST_MAIN_HOTKEY = TAG_SELECTOR_HOTKEY12,	
	TAG_SELECTOR_WEAPCONFIG_HOTKEY_LAST_SET_BY_USER = TAG_SELECTOR_WEAPCONFIG_HOTKEY3,
	TAG_SELECTOR_WEAPCONFIG_HOTKEY_LAST	=  TAG_SELECTOR_WEAPCONFIG_HOTKEY_FOR_STATES,
	TAG_SELECTOR_HOTKEY_LAST = TAG_SELECTOR_WEAPCONFIG_HOTKEY_LAST,
};

//----------------------------------------------------------------------------
struct TAG_DEFINITION
{
	char szName[DEFAULT_INDEX_SIZE];
	WORD wCode;
	BOOL bIsValueTimeTag;
	BOOL bIsHotkey;
};

//----------------------------------------------------------------------------
// STRUCTURES
//----------------------------------------------------------------------------
struct UNIT_TAG
{
	UNIT_TAG *				next;
	UNIT_TAG *				prev;
	int						selector;
};

enum HOTKEY_CONSTANTS
{
	HOTKEY_MAX_ITEMS = 2,
	HOTKEY_MAX_SKILLS = 2,
};

struct UNIT_TAG_HOTKEY : UNIT_TAG
{
	UNITID	m_idItem[ HOTKEY_MAX_ITEMS ];
	int		m_nSkillID[ HOTKEY_MAX_SKILLS ];
	int		m_nLastUnittype;
};

struct UNIT_TAG_UNITID : UNIT_TAG
{
	UNITID	m_idUnit;
};

struct UNIT_TAG_WEAPONS : UNIT_TAG
{
	UNITID	m_idWeapons[ MAX_WEAPONS_PER_UNIT ];
};


#define VALUE_TIME_HISTORY 32
#define VALUE_TIME_HISTORY_MINUTES 60

struct UNIT_TAG_VALUE_TIME : UNIT_TAG
{
	unsigned int m_nCounts[VALUE_TIME_HISTORY];
	unsigned int m_nCurrent;
	unsigned int m_nSecondCurrent;
	unsigned int m_nMinuteCounts[VALUE_TIME_HISTORY_MINUTES];
	unsigned int m_nMinuteCurrent;
	unsigned int m_nTotalMeasured;
};

struct UNIT_TAG_GUID_OWNER : UNIT_TAG
{
	PGUID guidOwner;
};

struct UNIT_TAG_LAST_KNOWN_GOOD_POSITION : UNIT_TAG
{
	VECTOR vLastKnownGoodPosition;
	GAME_TICK tiLastKnownGoodPositionReceivedTick;
};

struct UNIT_TAG_PICKUP : UNIT_TAG
{
	PGUID	guidUnit;
	PGUID	guidParty;
};

struct UNIT_TAG_GUILD_ASSOCIATION : UNIT_TAG
{
	WCHAR wszGuildName[MAX_GUILD_NAME];
	GUILD_RANK eGuildRank;
	WCHAR wszGuildRankName[MAX_CHARACTER_NAME];
};


//----------------------------------------------------------------------------
// FUNCTIONS
//----------------------------------------------------------------------------

const TAG_DEFINITION *TagGetDefinition(
	int nTag);
	
void UnitAddTag(
	UNIT * unit,
	UNIT_TAG * tag);

UNIT_TAG * UnitGetTag(
	UNIT * unit,
	int selector);

UNIT_TAG * UnitGetTagNext(
	UNIT * unit,
	UNIT_TAG * tag);

void UnitRemoveTag(
	UNIT * unit,
	UNIT_TAG * tag);

void UnitFreeTags(
	UNIT * unit);

int GetValueTimeTagValue(
	UNIT * unit,
	int time,
	TAG_SELECTOR eTagSelector);

int GetValueTimeTagMinutesValue(
	UNIT * unit,
	int time,
	TAG_SELECTOR eTagSelector);

int GetValueTimeTagSum(
	UNIT * unit,
	int time,
	TAG_SELECTOR eTagSelector);

int GetValueTimeTagMinutesSum(
	UNIT * unit,
	int time,
	TAG_SELECTOR eTagSelector);

void ClearValueTimeTag(
	UNIT * unit,
	TAG_SELECTOR eTagSelector);

//----------------------------------------------------------------------------
// INLINE FUNCTIONS
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
inline UNIT_TAG_HOTKEY * UnitAddHotkeyTag(
	UNIT * unit,
	int slot)
{
	ASSERT_RETNULL(unit);
	GAME* game = UnitGetGame(unit);
	ASSERT_RETNULL(game);

	if (TAG_SELECTOR_HOTKEY1 + slot > TAG_SELECTOR_WEAPCONFIG_HOTKEY_LAST)
		return NULL;

	UNIT_TAG_HOTKEY* tag = (UNIT_TAG_HOTKEY*)GMALLOCZ(game, sizeof(UNIT_TAG_HOTKEY));
	ASSERT_RETNULL(tag);

	tag->selector = TAG_SELECTOR_HOTKEY1 + slot;
	tag->m_idItem[0] = INVALID_ID;
	tag->m_idItem[1] = INVALID_ID;
	tag->m_nSkillID[0] =  INVALID_ID;
	tag->m_nSkillID[1] =  INVALID_ID;

	if (slot >= TAG_SELECTOR_WEAPCONFIG_HOTKEY1 && slot <= TAG_SELECTOR_WEAPCONFIG_HOTKEY_LAST)
	{
		// This is hacky and should probably not be hardcoded and should probably not be set here.
		tag->m_nSkillID[0] = 0;
		tag->m_nSkillID[1] = AppIsTugboat() ? 0 : 1;
	}
	tag->m_nLastUnittype = INVALID_ID;
	UnitAddTag(unit, tag);
	return tag;
}


//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
inline UNIT_TAG_HOTKEY * UnitGetHotkeyTag(
	UNIT * unit,
	int slot)
{
	ASSERT_RETNULL(unit);

	if (TAG_SELECTOR_HOTKEY1 + slot > TAG_SELECTOR_WEAPCONFIG_HOTKEY_LAST)
		return NULL;

	return (UNIT_TAG_HOTKEY*)UnitGetTag(unit, TAG_SELECTOR_HOTKEY1 + slot);
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
inline void UnitAddUnitIdTag(
	UNIT * unit,
	int nSelector,
	UNITID idUnit)
{
	ASSERT_RETURN(unit);
	GAME * game = UnitGetGame(unit);
	ASSERT_RETURN(game);

	UNIT_TAG_UNITID * tag = (UNIT_TAG_UNITID *)GMALLOCZ(game, sizeof(UNIT_TAG_UNITID));
	ASSERT_RETURN(tag);
	tag->selector = nSelector;
	tag->m_idUnit = idUnit;
	UnitAddTag(unit, tag);
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
inline void UnitSetUnitIdTag(
	UNIT * unit,
	int nSelector,
	UNITID idUnit)
{
	UNIT_TAG_UNITID * tag = (UNIT_TAG_UNITID *)UnitGetTag(unit, nSelector);
	if (!tag)
	{
		UnitAddUnitIdTag(unit, nSelector, idUnit);
		return;
	}
	tag->m_idUnit = idUnit;
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
inline UNITID UnitGetUnitIdTag(
	UNIT * unit,
	int nSelector)
{
	UNIT_TAG_UNITID * tag = (UNIT_TAG_UNITID *)UnitGetTag(unit, nSelector);
	if (!tag)
	{
		return INVALID_ID;
	}
	return tag->m_idUnit;
}


//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
inline void UnitAddWeaponsTag(
	UNIT * unit,
	int nSelector,
	UNIT * pWeapons[ MAX_WEAPONS_PER_UNIT ] )
{
	ASSERT_RETURN(unit);
	GAME * game = UnitGetGame(unit);
	ASSERT_RETURN(game);

	UNIT_TAG_WEAPONS * tag = (UNIT_TAG_WEAPONS *)GMALLOCZ(game, sizeof(UNIT_TAG_WEAPONS));
	ASSERT_RETURN(tag);
	tag->selector = nSelector;
	for ( int i = 0; i < MAX_WEAPONS_PER_UNIT; i++ )
	{
		tag->m_idWeapons[ i ] = UnitGetId( pWeapons[ i ] );
	}
	UnitAddTag(unit, tag);
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
inline void UnitGetWeaponsTag(
	UNIT * unit,
	int nSelector,
	UNIT * pWeapons[ MAX_WEAPONS_PER_UNIT ] )
{
	UNIT_TAG_WEAPONS * tag = (UNIT_TAG_WEAPONS *)UnitGetTag(unit, nSelector);
	if (!tag)
	{
		for ( int i = 0; i < MAX_WEAPONS_PER_UNIT; i++ )
		{
			pWeapons[ i ] = NULL;
		}
	} else {
		GAME * pGame = UnitGetGame( unit );
		for ( int i = 0; i < MAX_WEAPONS_PER_UNIT; i++ )
		{
			pWeapons[ i ] = UnitGetById( pGame, tag->m_idWeapons[ i ] );
		}
	}
}



//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
inline UNIT_TAG_VALUE_TIME * UnitAddValueTimeTag(
	MEMORY_FUNCARGS(UNIT * unit,
	int nSelector))
{
	ASSERT_RETNULL(unit);
	GAME * game = UnitGetGame(unit);
	ASSERT_RETNULL(game);

	UNIT_TAG_VALUE_TIME * tag = (UNIT_TAG_VALUE_TIME *)GMALLOCZFL(game, sizeof(UNIT_TAG_VALUE_TIME), file, line);
	ASSERT_RETNULL(tag);
	tag->selector = nSelector;
	UnitAddTag(unit, tag);
	return tag;
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#if DEBUG_MEMORY_ALLOCATIONS
#define UnitGetValueTimeTag(u, s)		UnitGetValueTimeTagDbg(u, s, __FILE__, __LINE__)
inline UNIT_TAG_VALUE_TIME * UnitGetValueTimeTagDbg(
	UNIT * unit,
	int nSelector,
	const char * file,
	unsigned int line)
#else
inline UNIT_TAG_VALUE_TIME * UnitGetValueTimeTag(
	UNIT * unit,
	int nSelector)
#endif
{
	UNIT_TAG_VALUE_TIME * pTag = (UNIT_TAG_VALUE_TIME *)UnitGetTag(unit, nSelector);
	if (!pTag)
	{
		pTag = UnitAddValueTimeTag(MEMORY_FUNC_PASSFL(unit, nSelector));
	}

	return pTag;
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
inline UNIT_TAG_LAST_KNOWN_GOOD_POSITION * UnitAddLastKnownGoodPositionTag(
	UNIT * unit)
{
	ASSERT_RETNULL(unit);
	GAME * game = UnitGetGame(unit);
	ASSERT_RETNULL(game);

	UNIT_TAG_LAST_KNOWN_GOOD_POSITION * tag = (UNIT_TAG_LAST_KNOWN_GOOD_POSITION *)GMALLOCZ(game, sizeof(UNIT_TAG_LAST_KNOWN_GOOD_POSITION));
	ASSERT_RETNULL(tag);
	tag->selector = TAG_SELECTOR_LAST_KNOWN_GOOD_POSITION;
	UnitAddTag(unit, tag);
	return tag;
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
inline UNIT_TAG_LAST_KNOWN_GOOD_POSITION * UnitGetLastKnownGoodPositionTag(
	UNIT * unit)
{
	UNIT_TAG_LAST_KNOWN_GOOD_POSITION * tag = (UNIT_TAG_LAST_KNOWN_GOOD_POSITION *)UnitGetTag(unit, TAG_SELECTOR_LAST_KNOWN_GOOD_POSITION);
	if (!tag)
	{
		tag = UnitAddLastKnownGoodPositionTag(unit);
	}

	return tag;
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
inline void UnitAddPickupTag(
	GAME * game,
	UNIT * unit,
	PGUID guidUnit,
	PGUID guidParty)
{
	UNIT_TAG_PICKUP * tag = (UNIT_TAG_PICKUP *)GMALLOCZ(game, sizeof(UNIT_TAG_PICKUP));
	tag->selector = TAG_SELECTOR_PICKUP;
	tag->guidUnit = guidUnit;
	tag->guidParty = guidParty;
	UnitAddTag(unit, tag);
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
void UnitAddOrUpdatePlayerGuildAssociationTag(
	GAME * game,
	UNIT * unit,
	const WCHAR * guildName,
	GUILD_RANK eGuildRank,
	const WCHAR * rankname );

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
void UnitGetPlayerGuildAssociationTag(
	UNIT * unit,
	WCHAR * guildNameDest,
	DWORD guildNameDestLen,
	GUILD_RANK & eGuildRank,
	WCHAR * rankNameDest = NULL,
	DWORD rankNameDestLen = 0 );


#endif // _UNITTAG_H_
