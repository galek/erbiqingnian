//----------------------------------------------------------------------------
// unittag.cpp
//
// (C)Copyright 2003, Flagship Studios. All rights reserved.
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
// INCLUDE
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "game.h"
#include "units.h"
#include "unittag.h"
#include "s_message.h" // also includes message.h
#include "clients.h"
#include "..\data_common\excel\invloc_hdr.h"	// auto-generated by inventory.xls | invloc
#include "skills.h"
#include "weaponconfig.h"
#include "gameunits.h"

#if !ISVERSION(SERVER_VERSION)
#include "globalindex.h"
#endif


//----------------------------------------------------------------------------
// CONSTANTS
//----------------------------------------------------------------------------
#define TAG_CODE_SIZE				16
#define TAG_BITCOUNT_SIZE			12


//----------------------------------------------------------------------------
// STRUCTS
//----------------------------------------------------------------------------
struct UNIT_TAG_HEAD
{
	struct UNIT_TAG *		first;
	struct UNIT_TAG *		last;
	int						selector;
};

struct UNIT_TAG_STRUCT
{
	struct UNIT_TAG_HEAD *	list;
	int						size;
	int						count;
};


//----------------------------------------------------------------------------
// FUNCTIONS
//----------------------------------------------------------------------------
void UnitFreeTags(
	UNIT * unit)
{
	ASSERT_RETURN(unit);
	if (!unit->m_pUnitTags)
	{
		return;
	}
	GAME * game = UnitGetGame(unit);
	ASSERT_RETURN(game);

	UNIT_TAG_STRUCT * tag_struct = unit->m_pUnitTags;
	for (int ii = 0; ii < tag_struct->count; ii++)
	{
		UNIT_TAG * curr = tag_struct->list[ii].first;
		while (curr)
		{
			UNIT_TAG * next = curr->next;
			GFREE(game, curr);
			curr = next;
		}
	}
	GFREE(game, tag_struct->list);
	GFREE(game, tag_struct);
	unit->m_pUnitTags = NULL;
}


//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
void UnitInitTags(
	UNIT * unit)
{
	ASSERT_RETURN(unit);
	if (unit->m_pUnitTags)
	{
		return;
	}
	GAME * game = UnitGetGame(unit);
	ASSERT_RETURN(game);

	unit->m_pUnitTags = (UNIT_TAG_STRUCT *)GMALLOCZ(game, sizeof(UNIT_TAG_STRUCT));
}


//----------------------------------------------------------------------------
// return index or insertion point (first larger selector)
//----------------------------------------------------------------------------
inline int sFindTagInList(
	UNIT_TAG_STRUCT * tag_struct,
	int selector)
{
	UNIT_TAG_HEAD * min = tag_struct->list;
	UNIT_TAG_HEAD * max = min + tag_struct->count;
	UNIT_TAG_HEAD * ii = min + (max - min) / 2;

	while (max > min)
	{
		if (ii->selector > selector)
		{
			max = ii;
		}
		else if (ii->selector < selector)
		{
			min = ii + 1;
		}
		else
		{
			return (int)(ii - tag_struct->list);
		}
		ii = min + (max - min) / 2;
	}
	return (int)(max - tag_struct->list);
}


//----------------------------------------------------------------------------
// return exact pointer
//----------------------------------------------------------------------------
inline UNIT_TAG_HEAD * sFindTagInListExact(
	UNIT_TAG_STRUCT * tag_struct,
	int selector)
{
	UNIT_TAG_HEAD * min = tag_struct->list;
	UNIT_TAG_HEAD * max = min + tag_struct->count;
	UNIT_TAG_HEAD * ii = min + (max - min) / 2;

	while (max > min)
	{
		if (ii->selector > selector)
		{
			max = ii;
		}
		else if (ii->selector < selector)
		{
			min = ii + 1;
		}
		else
		{
			return ii;
		}
		ii = min + (max - min) / 2;
	}
	return NULL;
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
const TAG_DEFINITION *TagGetDefinition(
	int nTag)
{
	return (const TAG_DEFINITION *)ExcelGetData( NULL, DATATABLE_TAG, nTag );
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
void UnitAddTag(
	UNIT * unit,
	UNIT_TAG * tag)
{
	ASSERT_RETURN(tag && tag->next == NULL && tag->prev == NULL);
	ASSERT_RETURN(unit);
	if (!unit->m_pUnitTags)
	{
		UnitInitTags(unit);
	}
	UNIT_TAG_STRUCT* tag_struct = unit->m_pUnitTags;
	ASSERT_RETURN(tag_struct);

	int ii = sFindTagInList(tag_struct, tag->selector);
	if (!(ii < tag_struct->count && tag_struct->list[ii].selector == tag->selector))
	{
		if (tag_struct->count >= tag_struct->size)
		{
			tag_struct->size++;
			tag_struct->list = (UNIT_TAG_HEAD*)GREALLOC(UnitGetGame(unit), tag_struct->list, tag_struct->size * sizeof(UNIT_TAG_HEAD));
		}
		if (ii < tag_struct->count)
		{
			MemoryMove(tag_struct->list + ii + 1, (tag_struct->size - ii - 1) * sizeof(UNIT_TAG_HEAD), tag_struct->list + ii, (tag_struct->count - ii) * sizeof(UNIT_TAG_HEAD));
		}
		tag_struct->count++;

		UNIT_TAG_HEAD* head = tag_struct->list + ii;
		head->selector = tag->selector;
		head->first = head->last = tag;
		return;
	}
	UNIT_TAG_HEAD* head = tag_struct->list + ii;
	if (!head->first)
	{
		head->first = tag;
	}
	tag->prev = head->last;
	if (tag->prev)
	{
		tag->prev->next = tag;
	}
	head->last = tag;
}


//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
UNIT_TAG * UnitGetTag(
	UNIT * unit,
	int selector)
{
	ASSERT_RETNULL(unit);
	if (!unit->m_pUnitTags)
	{
		return NULL;
	}
	UNIT_TAG_STRUCT * tag_struct = unit->m_pUnitTags;
	ASSERT_RETNULL(tag_struct);

	UNIT_TAG_HEAD * head = sFindTagInListExact(tag_struct, selector);
	if (!head)
	{
		return NULL;
	}
	return head->first;
}


//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
UNIT_TAG * UnitGetTagNext(
	UNIT * unit,
	UNIT_TAG * tag)
{
	ASSERT_RETNULL(unit && tag);
	UNIT_TAG_STRUCT * tag_struct = unit->m_pUnitTags;
	ASSERT_RETNULL(tag_struct);

	tag = tag->next;
	return tag;	
}


//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
void UnitRemoveTag(
	UNIT * unit,
	UNIT_TAG * tag)
{
	ASSERT_RETURN(unit && tag);
	UNIT_TAG_STRUCT * tag_struct = unit->m_pUnitTags;
	ASSERT_RETURN(tag_struct && tag_struct->list);

	UNIT_TAG_HEAD * head = sFindTagInListExact(tag_struct, tag->selector);
	ASSERT_RETURN(head);

	ASSERT_RETURN(tag->prev || head->first == tag);
	ASSERT_RETURN(tag->next || head->last == tag);

	if (head->first == tag)
	{
		head->first = tag->next;
	}
	if (head->last == tag)
	{
		head->last = tag->prev;
	}
	if (tag->next)
	{
		tag->next->prev = tag->prev;
	}
	if (tag->prev)
	{
		tag->prev->next = tag->next;
	}

	GFREE(UnitGetGame(unit), tag);
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
int GetValueTimeTagValue(
	UNIT * unit,
	int time,
	TAG_SELECTOR eTagSelector)
{
	if (!unit)
	{
		return 0;
	}

	UNIT_TAG_VALUE_TIME * pTag = UnitGetValueTimeTag(unit, eTagSelector);
	if (!pTag)
	{
		return 0;
	}

	int nOffset = (pTag->m_nCurrent + time) % VALUE_TIME_HISTORY;

	return pTag->m_nCounts[nOffset];
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
int GetValueTimeTagMinutesValue(
	UNIT * unit,
	int time,
	TAG_SELECTOR eTagSelector)
{
	if (!unit)
	{
		return 0;
	}

	UNIT_TAG_VALUE_TIME * pTag = UnitGetValueTimeTag(unit, eTagSelector);
	if (!pTag)
	{
		return 0;
	}

	int nOffset = (pTag->m_nMinuteCurrent + time) % VALUE_TIME_HISTORY_MINUTES;

	return pTag->m_nMinuteCounts[nOffset];
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
int GetValueTimeTagSum(
	UNIT * unit,
	int time,
	TAG_SELECTOR eTagSelector)
{
	if (!unit)
	{
		return 0;
	}
	ASSERT_RETZERO(time > 0);

	if (time > VALUE_TIME_HISTORY)
	{
		time = VALUE_TIME_HISTORY;
	}

	UNIT_TAG_VALUE_TIME * pTag = UnitGetValueTimeTag(unit, eTagSelector);
	if (!pTag)
	{
		return 0;
	}

	int nCount = 0;
	int nOffset = pTag->m_nCurrent;
	do
	{
		nCount += pTag->m_nCounts[nOffset];
		time--;
		nOffset--;
		if (nOffset < 0)
		{
			nOffset = VALUE_TIME_HISTORY-1;
		}
	}
	while(time > 0);

	return nCount;
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
int GetValueTimeTagMinutesSum(
	UNIT * unit,
	int time,
	TAG_SELECTOR eTagSelector)
{
	if (!unit)
	{
		return 0;
	}
	ASSERT_RETZERO(time > 0);

	if (time > VALUE_TIME_HISTORY_MINUTES)
	{
		time = VALUE_TIME_HISTORY_MINUTES;
	}

	UNIT_TAG_VALUE_TIME * pTag = UnitGetValueTimeTag(unit, eTagSelector);
	if (!pTag)
	{
		return 0;
	}

	int nCount = 0;
	int nOffset = pTag->m_nMinuteCurrent;
	do
	{
		nCount += pTag->m_nMinuteCounts[nOffset];
		time--;
		nOffset--;
		if (nOffset < 0)
		{
			nOffset = VALUE_TIME_HISTORY_MINUTES-1;
		}
	}
	while(time > 0);

	for(int i=0; i<VALUE_TIME_HISTORY; i++)
	{
		nCount += pTag->m_nCounts[i];
	}

	return nCount;
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
void ClearValueTimeTag(
	UNIT * unit,
	TAG_SELECTOR eTagSelector)
{
	if (!unit)
	{
		return;
	}

	UNIT_TAG_VALUE_TIME * pTag = UnitGetValueTimeTag(unit, eTagSelector);
	if (!pTag)
	{
		return;
	}

	memclear(pTag->m_nCounts, VALUE_TIME_HISTORY * sizeof(unsigned int));
	memclear(pTag->m_nMinuteCounts, VALUE_TIME_HISTORY_MINUTES * sizeof(unsigned int));
	pTag->m_nCurrent = 0;
	pTag->m_nSecondCurrent = 0;
	pTag->m_nMinuteCurrent = 0;

	// Keep total measured where it is
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
void UnitAddOrUpdatePlayerGuildAssociationTag(
	GAME * game,
	UNIT * unit,
	const WCHAR * guildName,
	GUILD_RANK eGuildRank,
	const WCHAR * rankName )
{
#if !ISVERSION(SERVER_VERSION)

	ASSERT_RETURN(game);
	ASSERT_RETURN(unit);

	BOOL newTag = FALSE;
	UNIT_TAG_GUILD_ASSOCIATION * tag = (UNIT_TAG_GUILD_ASSOCIATION*)UnitGetTag(unit, TAG_SELECTOR_PLAYER_GUILD_ASSOCIATION);
	if (!tag)
	{
		tag = (UNIT_TAG_GUILD_ASSOCIATION *)GMALLOCZ(game, sizeof(UNIT_TAG_GUILD_ASSOCIATION));
		ASSERT_RETURN(tag);
		newTag = TRUE;
	}

	tag->selector = TAG_SELECTOR_PLAYER_GUILD_ASSOCIATION;
	if (guildName && guildName[0])
	{
		PStrCopy(tag->wszGuildName, guildName, MAX_GUILD_NAME);
		tag->eGuildRank = eGuildRank;
		PStrCopy(tag->wszGuildRankName, WSTR_ARG(rankName), MAX_CHARACTER_NAME);
	}
	else
	{
		tag->wszGuildName[0] = 0;
		tag->eGuildRank = GUILD_RANK_INVALID;
		tag->wszGuildRankName[0] = 0;
	}

	if (newTag)
		UnitAddTag(unit, tag);

#endif
}

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
void UnitGetPlayerGuildAssociationTag(
	UNIT * unit,
	WCHAR * guildNameDest,
	DWORD guildNameDestLen,
	GUILD_RANK & eGuildRank,
	WCHAR * rankNameDest,
	DWORD rankNameDestLen )
{
#if !ISVERSION(SERVER_VERSION)

	ASSERT_RETURN(unit);
	ASSERT_RETURN(guildNameDest);

	UNIT_TAG_GUILD_ASSOCIATION * tag = (UNIT_TAG_GUILD_ASSOCIATION*)UnitGetTag(unit, TAG_SELECTOR_PLAYER_GUILD_ASSOCIATION);
	if (tag)
	{
		PStrCopy(guildNameDest, guildNameDestLen, tag->wszGuildName, MAX_GUILD_NAME);
		eGuildRank = tag->eGuildRank;

		if (rankNameDest)
		{
			if (tag->wszGuildRankName[0])
			{
				//	their guild rank name has been customized by their leader
				PStrCopy(rankNameDest, tag->wszGuildRankName, rankNameDestLen);
			}
			else
			{
				//	default guild rank name for their guild
				switch (eGuildRank)
				{
				case GUILD_RANK_LEADER:  PStrCopy(rankNameDest, GlobalStringGet(GS_GUILD_RANK_LEADER),  rankNameDestLen); break;
				case GUILD_RANK_OFFICER: PStrCopy(rankNameDest, GlobalStringGet(GS_GUILD_RANK_OFFICER), rankNameDestLen); break;
				case GUILD_RANK_MEMBER:  PStrCopy(rankNameDest, GlobalStringGet(GS_GUILD_RANK_MEMBER),  rankNameDestLen); break;
				case GUILD_RANK_RECRUIT: PStrCopy(rankNameDest, GlobalStringGet(GS_GUILD_RANK_RECRUIT), rankNameDestLen); break;
				default:
					ASSERT_MSG("Unknown guild rank for unit.");
					break;
				}
			}
		}
	}
	else
	{
		guildNameDest[0] = 0;
		eGuildRank = GUILD_RANK_INVALID;
		if (rankNameDest)
		{
			rankNameDest[0] = 0;
		}
	}

#endif
}
