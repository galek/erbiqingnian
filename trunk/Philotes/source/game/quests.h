//----------------------------------------------------------------------------
// FILE: s_quests.h
//
// (C)Copyright 2005, Flagship Studios. All rights reserved.
//----------------------------------------------------------------------------

#ifndef __QUESTS_H_
#define __QUESTS_H_

//----------------------------------------------------------------------------
// INCLUDES
//----------------------------------------------------------------------------
#ifndef _PLAYER_H_
#include "player.h"
#endif

#ifndef __QUEST_DEFAULT_H_
#include "quest_default.h"
#endif

#ifndef __S_TRADE_H_
#include "s_trade.h"
#endif

#ifndef _S_MESSAGE_H_
#include "s_message.h"
#endif

#ifndef __DIFFICULTY_H_
#include "difficulty.h"
#endif

#ifndef __METAGAME_H_
#include "metagame.h"
#endif

//#include "../data/excel/quest_hdr.h"						// auto generated by quest.xls
#include "../data/excel/quest_state_hdr.h"					// auto generated by quest.xls
#include "../data_common/excel/quest_state_value_hdr.h"		// auto generated by quest.xls
#include "../data_common/excel/quest_status_hdr.h"			// auto generated by quest.xls


//----------------------------------------------------------------------------
// FORWARD REFERENCES
//----------------------------------------------------------------------------
enum INTERACT_INFO;
struct QUEST;
struct UNIT;
enum UNIT_INTERACT;
enum OPERATE_RESULT;
struct LEVEL;
struct ITEMSPAWN_RESULT;
enum GENUS;
struct GAME;
enum UI_ELEMENT;
enum GLOBAL_INDEX;
struct ROOM;
struct ROOM_LAYOUT_GROUP;
enum NPC_DIALOG_TYPE;
enum USE_RESULT;
struct TAKE_ITEM;
enum OFFERID;
struct SUBLEVEL;
struct QUEST_GAME_DATA;

//----------------------------------------------------------------------------
// TYPES
//----------------------------------------------------------------------------
#define UNIT_INTERACT_INITIATE_DISTANCE					(1.5f)
#define UNIT_INTERACT_INITIATE_DISTANCE_SQUARED			(UNIT_INTERACT_INITIATE_DISTANCE * UNIT_INTERACT_INITIATE_DISTANCE)

#define UNIT_INTERACT_DISTANCE					(3.5f)
#define UNIT_INTERACT_DISTANCE_SQUARED			(UNIT_INTERACT_DISTANCE * UNIT_INTERACT_DISTANCE)
#define UNIT_INTERACT_CURSOR_DISTANCE			(7.0f)
#define UNIT_INTERACT_CURSOR_DISTANCE_SQUARED	(49.0f)
#define MONSTER_TARGET_MAXIMUM_DISTANCE			(100.0f)
#define MONSTER_TARGET_MAXIMUM_DISTANCE_SQUARED	((MONSTER_TARGET_MAXIMUM_DISTANCE)*(MONSTER_TARGET_MAXIMUM_DISTANCE))


//----------------------------------------------------------------------------
enum QUEST_CONSTANTS
{
	MAX_QUEST_CAST_MEMBERS = 10,
	MAX_INIT_QUEST_STATES = 8,
	MAX_QUEST_ALLOWED_DRLG = 16,
	MAX_QUEST_FUNCTION_LENGTH = 256,
	MAX_QUEST_LEVEL_DEST = 8,
	MAX_QUEST_LOG_OPTIONS = 8,
	MAX_QUEST_CAST = 8,
	MAX_QUEST_PREREQS = 8,
	MAX_QUEST_INTERESTING_GI = 64,
	MAX_QUEST_DELAYS_ACTIVE = 8,
	QUEST_MAX_PRELOAD_LEVELS = 16,		// arbitrary
	MAX_QUEST_GOSSIPS = 3,
	MAX_QUEST_ABANDON_ITEMS	= 32,		// arbitrary
	MAX_QUEST_COMPLETE_ITEMS = 32,		// arbitrary
};

//----------------------------------------------------------------------------
enum QUEST_STYLE
{
	QS_INVALID = -1,
	
	QS_STORY,			// story quests
	QS_FACTION,			// faction quests
	QS_CLASS,			// class specific quests
	QS_RANDOM,			// random quests
	QS_ADVENTURE,		// adventure style quests

	QS_NUM_STYLES		// keep this last please	
};

//----------------------------------------------------------------------------
// message type and result type enums moved to metagame.h -cmarch
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------

enum QUEST_UI_RADAR_INTERACTIONS
{
	QUEST_UI_RADAR_RESET = 0,
	QUEST_UI_RADAR_ADD_UNIT,
	QUEST_UI_RADAR_REMOVE_UNIT,
	QUEST_UI_RADAR_UPDATE_UNIT,
	QUEST_UI_RADAR_TURN_OFF,
	QUEST_UI_RADAR_TURN_ON,
	QUEST_UI_RADAR_TOGGLE,
};

//----------------------------------------------------------------------------

enum QUEST_UI_MESSAGE_TYPE
{
	QUIM_DIALOG = 0,
	QUIM_STRING,
	QUIM_GLOBAL_STRING,
	QUIM_GLOBAL_STRING_WITH_INT,
	QUIM_GLOBAL_STRING_SCORE,
	//
	QUIM_TUTORIAL_TIP,
};

//----------------------------------------------------------------------------
struct QUEST_LOG_OPTION
{
	int nUnitType;
	int nString;
};

//----------------------------------------------------------------------------
struct QUEST_STATE_DEFINITION
{
	char szName[ DEFAULT_INDEX_SIZE ];
	WORD wCode;								// code
	int nQuest;								// quest to be associated with
	BOOL bActivateWithQuest;				// when quest status becomes active, auto activate this state
	BOOL bRestorePoint;						// this state is a saved state, if the user quits with an quest active, the quest will restore to the latest restore point
	BOOL bShowLogOnActivate;				// show the log on activation of state
	BOOL bShowLogOnComplete;				// display log on completion of state
	BOOL bAutoTrackOnComplete;				// turn on tracking when this quest state is completed
	BOOL bNoQuickMessageOnUpdate;			// don't display the UI quick message when the log text is updated
	QUEST_LOG_OPTION tQuestLogOptions[ MAX_QUEST_LOG_OPTIONS ];
	int nDialogForState;					// recap of the dialog for the state
	int nNPCForState[2];					// class of NPC for state recap dialog
	int nMurmurString;						// Ask Murmur!(tm)
	int nDialogFullDesc;					// full description log of state
	int nQuestTemplate;						// inplace index of "Template" column in "quest" tab of quests.xls

	int nGossipNPC[MAX_QUEST_GOSSIPS];		// monster class of NPC for gossips
	int nGossipString[MAX_QUEST_GOSSIPS];	// string link for gossip
};

//----------------------------------------------------------------------------
struct QUEST_STATE
{	
	#ifdef _DEBUG
	const QUEST_STATE_DEFINITION *ptStateDef;	// row in .xls
	#endif
	
	int nQuestState;							// state row in .xls
	QUEST_STATE_VALUE eValue;					// value of state
	BOOL bGossipComplete[MAX_QUEST_GOSSIPS];	// did the person already read these gossips?
};

//----------------------------------------------------------------------------
typedef QUEST_MESSAGE_RESULT (* PFN_QUEST_MESSAGE_HANDLER)( QUEST *pQuest, QUEST_MESSAGE_TYPE eMessageType, const void *pMessage );

//----------------------------------------------------------------------------
struct CAST_MEMBER
{
	SPECIES spMember;			// who is the cast member
	UNITID idUnit;				// id instance of cast member in world
};

//----------------------------------------------------------------------------
struct CAST
{
	CAST_MEMBER tCastMember[ MAX_QUEST_CAST_MEMBERS ];
	int nNumCastMembers;
};

//----------------------------------------------------------------------------
enum QUEST_FLAGS
{
	QF_CAST_NEEDS_UPDATE_BIT,				// cast needs info update
	QF_LEVEL_TRANSITION,					// level has been transitioned, wait until out of limbo
	QF_PARTY_KILL,							// quest gives credit for monster kills by party members, in addition to owner of quest
	QF_DELAY_NEXT,							// quest delay start of next quest flag
	QF_DELAY_CURRENT,						// quest delay start of this quest (repeatable)
	QF_TRACKING,							// (client) the player is tracking this quest in the quest log
	QF_VERSIONING_BIT,						// currently being versioned and updated
	QF_GOSSIP,								// this quest has current gossip info
};

//----------------------------------------------------------------------------
enum QUEST_GLOBAL_FLAGS
{
	QGF_ROOMS_ACTIVATED,					// the "room activated count" in the quest globals structure is updated, send messages to the player's quests
	QGF_QUESTS_SETUP,						// quests have been setup and initialized for this player
};

//----------------------------------------------------------------------------
enum QUEST_GLOBAL_FIX_FLAGS
{
	QGFF_OLD_QUEST_ITEMS,					// there were several quest items that could remain in your inventory when you completed the quest that should have been removed. this is the fix.
	QGFF_BROKEN_FAWKES_DAY_QUEST_REWARD,	// the final blueprint for the main fawkes day quest reward was screwed up and many people didn't get it. now fixing by giving it to people that completed the quest
	QGFF_OLD_PORTALBOOST_QUEST_ITEMS,		// there were several quest items involved in the PortalBoost quest that could remain in your inventory when you completed the quest that should have been removed. this is the fix.
};

//----------------------------------------------------------------------------
struct QUEST_CAST_OPTION
{
	int nUnitType;
	int nMonsterClass;
};

//----------------------------------------------------------------------------
struct QUEST_STATUS_DEFINITION
{
	char szName[DEFAULT_INDEX_SIZE];
	WORD wCode;
	BOOL bIsGood;							// is a "good" status (like, it's active or your've completed it, but not that you haven't got it or you failed it etc)
};


//----------------------------------------------------------------------------
struct QUEST_STATE_VALUE_DEFINITION
{
	char szName[DEFAULT_INDEX_SIZE];
	WORD wCode;
};

//----------------------------------------------------------------------------
struct QUEST_CAST_DEFINITION
{
	char szName[DEFAULT_INDEX_SIZE];			// name
	WORD wCode;
	QUEST_CAST_OPTION tCastOptions[MAX_QUEST_CAST];
};

//----------------------------------------------------------------------------
enum QUEST_WELL_KNOWN_CAST
{
	WKC_INVALID = -1,			// invalid value
	
	WKC_GIVER,					// gives the quest
	WKC_REWARDER,				// gives reward for quest
	
	WCK_NUM_WELL_KNOWN_CAST		// keep this last please
};

//----------------------------------------------------------------------------
enum QUEST_PARAM_FLAGS
{
	QPF_FIRST_GAME_JOIN_BIT,	// this is the first game a player is joining (as opposed to switching instanes or server from inside another game)
};

//----------------------------------------------------------------------------
struct QUEST_FUNCTION_PARAM
{

	QUEST *pQuest;				// the quest
	UNIT *pPlayer;				// player of the quest
	DWORD dwQuestParamFlags;	// see QUEST_PARAM_FLAGS
	
	QUEST_FUNCTION_PARAM::QUEST_FUNCTION_PARAM( void )
		:	pQuest( NULL ),
			pPlayer( NULL ),
			dwQuestParamFlags( 0 )
	{ }
	
};

//----------------------------------------------------------------------------
typedef void (* PFN_QUEST_FUNCTION)( const QUEST_FUNCTION_PARAM &tParam );

//----------------------------------------------------------------------------
enum QUEST_FUNCTION_TYPE
{
	QFUNC_INVALID = -1,
	
	QFUNC_INIT,
	QFUNC_FREE,
	QFUNC_ON_ENTER_GAME,
	QFUNC_ON_COMPLETE,
	
	QFUNC_NUM_FUNCTIONS			// keep this last
	
};

//----------------------------------------------------------------------------
struct QUEST_FUNCTION
{
	char szFunctionName[ MAX_QUEST_FUNCTION_LENGTH ];
	SAFE_FUNC_PTR(PFN_QUEST_FUNCTION, pfnFunction);
};

//----------------------------------------------------------------------------
struct QUEST_FUNCTION_TABLE
{
	QUEST_FUNCTION tTable[ QFUNC_NUM_FUNCTIONS ];
};

//----------------------------------------------------------------------------
struct QUEST_DEFINITION
{
	char szName[ DEFAULT_INDEX_SIZE ];			// name
	WORD wCode;									// code	
	QUEST_STYLE eStyle;							// quest style
	int	nStringKeyName;							// display name
	BOOL bSubscriberOnly;						// subscriber only
	BOOL bMultiplayerOnly;						// multiplayer only
	BOOL bStartingQuestCheat;					// This is the current active starting quest when starting with cheats
	BOOL bQuestCheatCompleted;					// Force this quest to be completed when cheat levels are active
	BOOL bCloseOnComplete;						// if we are completing this quest, there is no reward to take, so close it out
	BOOL bRepeatable;							// if we are completing this quest, let the player do it again (set to inactive)
	BOOL bHideQuestLog;							// don't show this quest in the quest log
	int nRepeatRate;							// rate at which you can repeat this quest (in seconds)
	BOOL bSkipActivateFanfare;					// don't do start fx (sound,particle,msg)
	BOOL bSkipCompleteFanfare;					// don't do end fx (sound,particle,msg)
	int nEndOfAct;								// 0 = nothing, 1-5 gets special end of act messages
	BOOL bAutoTrackOnActivate;					// automatically turn on tracking when this quest is activated
	int	nLevelDefAutoActivate;					// quest auto activates (if inactive) when this level is entered into
	BOOL bOneDifficulty;						// this quest has only one difficulty. when you complete it, it completes it for all difficulties
	int nQuestPrereqs[ MAX_QUEST_PREREQS ];		// prerequisite quests for this quest (if any)
	BOOL bUnavailable;							// this quest is currently turned off
	int nMinLevelPrereq;						// minimum player level required for quest activation
	int nMaxLevelPrereq;						// maximum player level required for quest activation
	int nFactionTypePrereq;						// faction the player needs a min score with to activate the quest
	int nFactionAmountPrereq;					// min faction score a player needs to activate the quest
	int nLevelDefPreloadedWith[ QUEST_MAX_PRELOAD_LEVELS ];		// contents of this quest are preloaded on these levels if the quest is active
	int	nStartingItemsTreasureClass;			// treasure class of item(s) given when quest is accepted
	BOOL bRemoveStartingItemsOnComplete;		// remove the starting items from the player's inventory when the quest is completed
	int	nOfferReward;							// reward
	int nCastGiver;								// quest giver
	int nLevelDefQuestStart;					// level where a story quest starts for putting the '!' on the world-map screen
	int nCastRewarder;							// quest rewarder
	int	nLevelDefRewarderNPC;					// level where the player must complete the quest by talking to the rewarder NPC 
	int nGiverItem;								// quest can be given by an interactive item instead of an NPC
	int nGiverItemMonster;						// monster class which drops nGiverItem
	int nGiverItemLevelDef;						// level to kill monsters in to get the nGiverItem drop
	float fGiverItemDropRate;					// percentage chance for a monster to drop the nGiverItem, [0.0, 1.0]
	int nLevel[ NUM_DIFFICULTIES ];				// quest level, used to determine base experience and money rewards from monlevel.xls
	float fExperienceMultiplier;				// experience reward multiplier, used with experience from monlevel.xls for quest level	
	float fMoneyMultiplier;						// money reward multiplier, used with money from monlevel.xls for quest level		
	int nStatPoints;							// number of stat points to reward			
	int nSkillPoints;							// number of skill points to reward			
	int nFactionTypeReward;						// on quest complete, the faction to change the player's score with
	int nFactionAmountReward;					// on quest complete, the faction amount to change the player's score with

	QUEST_FUNCTION_TABLE tFunctions;			// functions

	int nWarpToOpenActivate;					// Warp to open when the quest activates, or close when it is abandoned
	int nWarpToOpenComplete;					// Warp to open when the quest completes

	int nAbandonItemList[ MAX_QUEST_ABANDON_ITEMS ];	// list of items to remove when the quest gets abandoned
	int nCompleteItemList[ MAX_QUEST_COMPLETE_ITEMS ];	// list of items to remove when the quest gets completed
		
	// versioning information
	char szVersionFunction[ MAX_QUEST_FUNCTION_LENGTH ];		// custom version function
	SAFE_FUNC_PTR(PFN_QUEST_FUNCTION, pfnVersionFunction );		// custom version function
	int bRemoveOnJoinGame;						// remove this quest from the player when they first join a game
	BOOL bBeatGameOnComplete;					// last story quest, beat current mode when player completes this quest 
	BOOL bUpdatePartyKillOnSetup;				// update party kill on setup
	
	int nWeight;								// weight of quest (for random adventures)
	float flRadius;								// spaceial requirement to place adventure
	float flHeight;								// spaceial requirement to place adventure
	float flFlatZTolerance;						// spacial requirement to place adventure
	int nDRLGStyleAllowed[ MAX_QUEST_ALLOWED_DRLG ];	// some quests can only appear in certain drlgs	styles
	int nLevelDefDestinations[ MAX_QUEST_LEVEL_DEST ];
	char szAdventureLayout[ MAX_XML_STRING_LENGTH ];	// layout to use for adventure
	int nObjectAdventure;						// temp, if this is cool, we'll use layouts instead of this
	int nTreasureClassTreasureRoom;				// treasure class used for treasure rooms

	// data for template quests
	int nTemplate;								// inplace index for template column items in "Quest" tab of quest.xls
	int nDescriptionDialog;						// quest dialog ID for initial quest description	
	int nIncompleteDialog;						// quest dialog ID on quest completion
	int nCompleteDialog;						// quest dialog ID when the player comes back to NPC before completing
	int nRewardDialog;							// quest dialog ID when reward is offered
	int nUnavailableDialog;						// quest dialog ID when quest is not available
	int nAcceptButtonText;						// text to display on the accept button (generally "Accept Quest")
	float fTimeLimit;							// maximum time until quest failure after activation
	int nObjectiveMonster;						// monster class to spawn for a hunt quest, kill in an infestation quest, or kill for drops in a collect quest
	int nObjectiveUnitType;						// UnitType of objective monster, for cases where the monster class could be confused with multiple hierarchies (zombie)
	int nObjectiveObject;						// object class or primary importance to the quest (operate: which must be operated to complete the quest, use item: object to use the item on)
	BOOL bDisableSpawning;						// disable quest spawning of nObjectiveObject and nObjectiveMonster 
	int nObjectiveCount;						// the number associated with a completion requirement, such as "collect X items" or "kill X monsters"
	float fCollectDropRate;						// percentage chance for a monster to drop the item being collected, [0.0, 1.0]
	int nCollectItem;							// item class of item to collect
	float fExplorePercent;						// percentage of accessible rooms to visit in a level to complete an explore quest [0.0, 1.0]. Zero means just visit the level
	char szSpawnNodeLabel[ DEFAULT_INDEX_SIZE ];// spawn on nodes with this label, if any exist (otherwise spawn as usual)
	int nSpawnCount;							// how many to spawn
	int	nStringKeyNameOverride;					// display name to set on the primary unit of importance to the quest (Escort: NPC to Escort)
	int	nStringKeyNameInLogOverride;			// name in quest log to use for primary unit of importance to the quest (Escort: NPC to Escort)

	int nLogOverrideState;						// state to override the quest text for
	int nLogOverrideString;						// string to display instead of default for the above state
	
	SUBLEVEL_TYPE eSubLevelTypeTruthOld;		// this quest uses a truth, this is the old truth sublevel
	SUBLEVEL_TYPE eSubLevelTypeTruthNew;		// this quest uses a truth, this is the new truth sublevel
	int nQuestStateAdvanceToAtSubLevelTruthOld;	// when entering an old truth sublevel, this quest is automatically activated and advanced to this state
	int nMonsterBoss;							// monster that is the boss for this quest
	int nGlobalThemeRequired;					// global theme required for this quest to activate
	int nLootBonusPerPlayerWithQuest;			// percentage of bonus boss loot to drop for each extra player with the quest

};

//----------------------------------------------------------------------------
struct QUEST
{

	const QUEST_DEFINITION *pQuestDef;		// row in quest.xls
	int nQuest;								// row in quest.xls
	int nVersion;							// version of this quest
	int nDifficulty;						// difficulty this quest is for
		
	int nStringKeyName;						// string with quest name
	QUEST_STATUS eStatus;					// status
	UNIT * pPlayer;							// player this quest data is associated with

	QUEST_STATE *pStates;					// quest states
	int nNumStates;							// number of states
	int nQuestStateActiveLog;				// state used to display active full log (if any)
			
	DWORD dwQuestFlags;						// see QUEST_FLAGS
	int nDelay;								// delay count
					
	PFN_QUEST_MESSAGE_HANDLER pfnMessageHandler;	// message handler	
	CAST tCast;								// quest cast members
	DWORD dwQuestMessageFlags;				// see QSMF_xxx (metagame.h)
	
	void *pQuestData;						// data specific for each quest
		
	QUEST_TEMPLATE tQuestTemplate;			// shared data for template quests (kill/collect variants)

	QUEST_GAME_DATA * pGameData;			// shared data for quest games
	
};

//----------------------------------------------------------------------------
struct QUEST_GLOBALS
{
	// client & server data
	BOOL bQuestsRestored;
	QUEST tQuests[ NUM_QUESTS ][ NUM_DIFFICULTIES ];
	DWORD dwQuestGlobalFlags;			// see QUEST_GLOBAL_FLAGS

	// used for level transition flags
	int nLevelOldDef;
	int nLevelNewDef;
	int nLevelNewDRLGDef;

	// used for quest delays
	int nNumActiveQuestDelays;
	int nQuestDelayIds[ MAX_QUEST_DELAYS_ACTIVE ];
	int nQuestDelayBit[ MAX_QUEST_DELAYS_ACTIVE ];

	// used for ending Test of Hope (maybe global flags in the future)
	BOOL bTestOfHopeCheck;

	// used for explore template side quests. This is an optimization, 
	// so I can track per-player room activation attempts without
	// sending tons of redundant messages for rooms that are already active.
	// server only
	DWORD dwRoomsActivated[DWORD_FLAG_SIZE(MAX_ROOMS_PER_LEVEL)];	// bit is set when the player attempts to activate a room in current level
	int nDefaultSublevelRoomsActivated;								// number of rooms in the default sublevel the player has activated

	// Client only data below
	int nActiveClientQuest;
	BOOL bAllInitialQuestStatesReceived;

	// client - used for '!' on world map
	int nLevelNextStoryDef;
	BOOL bStoryQuestActive;
};

//----------------------------------------------------------------------------
struct APP_QUEST_GLOBAL
{
	// these are the same for all players and difficulty levels
	GLOBAL_INDEX eInterestingGI[ MAX_QUEST_INTERESTING_GI ];		// interesting GIs for this quest
	int nNumInterstingGI;											// size of eInteresting[]
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_INTERACT
{
	UNITID idPlayer;
	UNITID idSubject;
	int nForcedQuestID;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_INTERACT_GENERIC
{
	UNITID idPlayer;
	UNITID idSubject;
	UNIT_INTERACT eInteract;
	int nForcedQuestID;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_MONSTER_DYING
{
	UNITID idKiller;
	UNITID idVictim;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_MONSTER_KILL
{
	UNITID idKiller;
	UNITID idVictim;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_TALK_STOPPED
{
	UNITID idTalkingTo;			// who they were talking to
	int nDialog;				// what was stopped
	int nRewardSelection;		//	which reward was selected by index
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_TALK_CANCELLED
{
	UNITID idTalkingTo;			// who they were talking to
	int nDialog;				// what was cancelled
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_INTERACT_INFO
{
	UNITID idSubject;	// npc, object, item, etc we're asking the interact question on
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_CAN_OPERATE_OBJECT
{
	UNITID idOperator;		// can be INVALID_ID for "anybody"!
	UNITID idObject;		// what to operate
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_CREATE_LEVEL
{
	GAME *pGame;
	LEVEL *pLevel;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_ENTER_LEVEL
{
	int nLevelOldDef;
	int nLevelNewDef;
	int nLevelNewDRLGDef;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_LEAVE_LEVEL
{
	UNIT * pPlayer;
	int nLevelNextDef;
	int nLevelArea;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_SUBLEVEL_TRANSITION
{
	UNIT *pPlayer;
	SUBLEVEL *pSubLevelNew;
	SUBLEVEL *pSubLevelOld;
	ROOM * pOldRoom;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_ENTER_ROOM
{
	UNIT *pPlayer;
	ROOM *pRoom;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_OBJECT_OPERATED
{
	UNIT *pOperator;
	UNIT *pTarget;
	BOOL bDoTrigger;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_LOOT
{
	UNIT *pSpawer;
	ITEMSPAWN_RESULT *pLoot;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_PICKUP
{
	UNIT *pPlayer;
	UNIT *pPickedUp;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_ITEM_CRAFTED
{
	UNITID idItemCrafted;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_ATTEMPTING_PICKUP
{
	UNIT *pPlayer;
	UNIT *pPickedUp;
	int nQuestIndex;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_DROPPED_ITEM
{
	UNIT *pPlayer;
	int nItemClass;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_PLAYER_APPROACH
{
	UNITID idPlayer;
	UNITID idTarget;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_OPEN_UI
{
	UI_ELEMENT eElement;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_STATE
{
	int nQuestState;
	QUEST_STATE_VALUE eValue;
	UNIT * pPlayer;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_STATE_CHANGED
{
	int nQuestState;
	QUEST_STATE_VALUE eValueOld;
	QUEST_STATE_VALUE eValueNew;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_STATUS
{
	QUEST_STATUS eStatusOld;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_MONSTER_INIT
{
	UNIT *pMonster;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_ABORT
{
	UNIT * pPlayer;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_TIP_STOPPED
{
	int nTip;
};

//----------------------------------------------------------------------------
#define CAN_RUN_DRLG_RULE_NAME_SIZE		64

struct QUEST_MESSAGE_CAN_RUN_DRLG_RULE
{
	int		nLevelDefId;
	int		nDRLGDefId;
	char	szRuleName[CAN_RUN_DRLG_RULE_NAME_SIZE];
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_CAN_USE_ITEM
{
	UNITID idPlayer;
	UNITID idItem;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_USE_ITEM
{
	UNITID idPlayer;
	UNITID idItem;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_KILL_DROP_GIVER_ITEM
{
	UNIT *pKiller;
	UNIT *pVictim;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_PARTY_KILL
{
	UNIT *pKiller;
	UNIT *pVictim;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_UNIT_STATE_CHANGE
{
	UNIT * pPlayer;
	int nState;
	BOOL bStateSet;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_IS_UNIT_VISIBLE
{
	UNIT *	pUnit;
	int		nUnitClass;
	int		nLevelDefId;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_GAME_MESSAGE
{
	int		nCommand;
	UNIT *	pUnit;
	DWORD	dwData;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_AI_UPDATE
{
	UNIT *	pUnit;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_SKILL_NOTIFY
{
	int		nSkillIndex;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_TOGGLE_PORTAL
{
	UNIT * pPortal;
	int nLevelDefDestination;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_BACK_FROM_MOVIE
{
	UNITID	idPlayer;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_LEVEL_GET_START_LOCATION
{
	//inputs
	LEVELID idLevel;

	//outputs
	ROOM *pRoom;
	VECTOR vPosition;
	VECTOR vFaceDirection;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_REMOVE_FROM_TEAM
{
	int nTeam;
};

//----------------------------------------------------------------------------
struct QUEST_MESSAGE_PLAYER_DIE
{
	UNIT *pKiller;
};

//----------------------------------------------------------------------------
// Prototypes
//----------------------------------------------------------------------------

QUEST_GLOBALS * QuestGlobalsGet(
	UNIT * player );

inline BOOL QuestsAreDisabled(
	UNIT * player )
{
	return UnitTestFlag( player, UNITFLAG_DISABLE_QUESTS );
}

BOOL QuestExcelPostProcess(
	struct EXCEL_TABLE * table);

const QUEST_STATUS_DEFINITION *QuestStatusGetDefinition(
	QUEST_STATUS eStatus);
		
const QUEST_DEFINITION *QuestGetDefinition( 
	int nQuest);

const QUEST_DEFINITION *QuestGetDefinition( 
	const QUEST *pQuest);

const QUEST_STATE_DEFINITION *QuestStateGetDefinition( 
	int nQuestState);

const QUEST_CAST_DEFINITION *QuestCastGetDefinition( 
	int nCast);

const char *QuestGetDevName(
	QUEST *pQuest);
	
void QuestsInitForApp(
	void);

void QuestsFreeForApp(
	void);
	
void QuestInit(
	QUEST *pQuest,
	UNIT * player,
	int nQuestDef,
	int nDifficulty);
	
void QuestsInit(
	UNIT * player );
	
void QuestsFree(
	UNIT * player );

DWORD QuestGetCode(
	QUEST *pQuest);

int QuestGetIndexByCode(
	DWORD dwCode);
		
QUEST * QuestGetQuest(
	UNIT * player,
	int nQuest,
	BOOL bAutomaticallyVersion = TRUE);

int QuestGetDifficulty(
	QUEST *pQuest);
	
// this is mainly for internal quest system use
QUEST *QuestGetQuestByDifficulty(
	UNIT *player,
	int nQuest,
	int nDifficulty,
	BOOL bAutomaticallyVersion = TRUE);

GAME *QuestGetGame( 
	QUEST *pQuest);

UNIT *QuestGetPlayer(
	QUEST *pQuest);

LEVEL *QuestGetPlayerLevel(
	QUEST *pQuest);

void QuestTemplateInit( 
	QUEST_TEMPLATE* pQuestTemplate);

void QuestStateInit( 
	QUEST_STATE *pState,
	int nQuestState);

void QuestStatesFree(
	QUEST *pQuest);
	
void QuestsStatesInit(
	QUEST *pQuest);
	
QUEST_STATE *QuestStateGetPointer(
	QUEST *pQuest,
	int nQuestState);
	
QUEST_STATE_VALUE QuestStateGetValue(
	QUEST *pQuest,
	int nQuestState);

QUEST_STATE_VALUE QuestStateGetValue(
	QUEST *pQuest,
	const QUEST_STATE *pState);

BOOL QuestStateIsActive(
	QUEST *pQuest,
	int nQuestState);

BOOL QuestStateIsHidden(
	QUEST *pQuest,
	int nQuestState);

BOOL QuestStateIsComplete(
	QUEST *pQuest,
	int nQuestState);

BOOL QuestStateIsFailed(
	QUEST *pQuest,
	int nQuestState);
	
QUEST_STATE *QuestStateGetByIndex(
	const QUEST *pQuest,
	int nIndex);

int QuestGetStateIndex(
	const QUEST *pQuest,
	int nQuestState);
		
QUEST_STATUS QuestGetStatus(
	QUEST *pQuest);

BOOL QuestStatusIsGood(
	QUEST *pQuest);
	
BOOL QuestIsInactive(
	QUEST *pQuest);
	
BOOL QuestIsActive(
	QUEST *pQuest);
	
BOOL QuestIsComplete(
	QUEST *pQuest,
	BOOL bOrClosed = TRUE);
	
BOOL QuestIsOffering(
	QUEST *pQuest);
	
BOOL QuestIsClosed(
	QUEST *pQuest);
	
BOOL QuestIsFailed(
	QUEST *pQuest);

BOOL QuestIsDone(
	QUEST *pQuest);
		
OPERATE_RESULT QuestsCanOperateObject(
	UNIT *pOperator,
	UNIT *pObject);
	
USE_RESULT QuestsCanUseItem(
	UNIT * pPlayer,
	UNIT * pItem );

BOOL QuestsUnitIsVisible(
	UNIT * pPlayer,
	UNIT * pUnit );

QUEST_MESSAGE_RESULT QuestSendMessageToQuest(
	QUEST *pQuest,
	QUEST_MESSAGE_TYPE eMessageType,
	void *pMessage);

QUEST_MESSAGE_RESULT QuestSendMessage(
	UNIT * pPlayer,
	QUEST_MESSAGE_TYPE eMessageType,
	void *pMessage,
	DWORD dwFlags = QSMF_ALL );

void QuestSendState(
	QUEST *pQuest,
	int nQuestState,
	BOOL bRestore = FALSE);

BOOL QuestStateSet( 
	QUEST *pQuest, 
	int nQuestState,
	QUEST_STATE_VALUE eValue,
	BOOL bUpdateCastInfo = TRUE,
	BOOL bIgnoreStatus = FALSE,
	BOOL bSetAutoTrack = TRUE);

SPECIES QuestCastGetSpecies(
	QUEST *pQuest,
	int nCast);

int QuestGetExistingRewardItems( 
	QUEST *pQuest,
	ITEMSPAWN_RESULT &tResult);

int QuestGetExperienceReward( 
	QUEST *pQuest);

int QuestGetMoneyReward( 
	QUEST *pQuest);

int QuestGetStatPointReward(
	QUEST *pQuest );

int QuestGetSkillPointReward( 
	QUEST *pQuest);

void s_QuestTransportToNewTruthRoom( 
	UNIT *pPlayer,
	QUEST *pQuest = NULL,
	GLOBAL_INDEX eGITalkToAfterTransport = GI_INVALID,
	int nDialogToSpeakAfterTransport = INVALID_LINK);

void s_QuestTruthRoomEnter(
	UNIT *pPlayer,
	SUBLEVEL *pTruthRoom,	
	QUEST *pQuest,
	int nQuestStateToAdvanceTo);
	
void s_QuestSendRadarMessage(
	QUEST * pQuest,
	QUEST_UI_RADAR_INTERACTIONS eMsg,
	UNIT * pUnit = NULL,
	int nType = 0,
	DWORD dwColor = 0);

BOOL QuestRemoveOnJoinGame(
	int nQuest);

BOOL QuestRemoveOnJoinGame(
	const QUEST *pQuest);

int QuestGetVersion( 
	const QUEST *pQuest);

int QuestGetCurrentVersion( 
	const QUEST *pQuest);

void QuestTemplateLookupFunctions(
	struct QUEST_TEMPLATE_DEFINITION *pQuestTemplateDef);

void QuestRunFunction(
	QUEST *pQuest,
	QUEST_FUNCTION_TYPE eType,
	const QUEST_FUNCTION_PARAM &tParam);

APP_QUEST_GLOBAL *QuestGetAppQuestGlobal(
	int nQuest);
	
int QuestUseGI(
	QUEST *pQuest,
	GLOBAL_INDEX eGlobalIndex);
	
BOOL QuestUsesUnitClass(
	QUEST *pQuest,
	GENUS eGenus,
	int nClass);
	
void QuestAutoTrack(
	QUEST * pQuest);

BOOL QuestPlayCanAcceptQuest(
	UNIT *pPlayer,
	QUEST *pQuest);

//----------------------------------------------------------------------------
typedef void (* PFN_QUEST_ITERATE)( QUEST *pQuest, void *pCallbackData );

//----------------------------------------------------------------------------
enum QUEST_ITERATE_FLAGS
{
	QIF_ALL_DIFFICULTIES,		// iterate quests for all difficulty level (not just current one)
};

void QuestIterateQuests(
	UNIT *pPlayer,
	PFN_QUEST_ITERATE pfnCallback,
	void *pCallbackData,
	DWORD dwQuestIterateFlags = 0,		// see QUEST_ITERATE_FLAGS	
	BOOL bAutomaticallyVersion = TRUE);
	
int QuestGetMonsterLevel(
	QUEST *pQuest,
	LEVEL *pLevel,
	int nMonsterClass,
	int nMonsterLevelForNormal);

#endif
