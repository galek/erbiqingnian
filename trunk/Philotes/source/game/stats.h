//----------------------------------------------------------------------------
//	stats.h
//  Copyright 2003, Flagship Studios
//----------------------------------------------------------------------------
#ifndef _STATS_H_
#define _STATS_H_

//----------------------------------------------------------------------------
// INCLUDES (put in stats.h)
//----------------------------------------------------------------------------
#ifndef _EXCEL_COMMON_H_
#include "excel_common.h"
#endif

#ifndef _EXCEL_H_
#include "excel.h"
#endif

#include "..\data_common\excel\stats_hdr.h"				// auto-generated by excel
#include "..\data_common\excel\statsselector_hdr.h"		// auto-generated by excel

//----------------------------------------------------------------------------
// CONSTANTS
//----------------------------------------------------------------------------
#define STATS_NAME_SIZE					64
#define STATS_NUM_ASSOCATED				2								// size of m_nAssociatedStat array (regen, etc)
#define STAT_BITS						((unsigned int)10)				// number of bits used to store stat
#define PARAM_BITS						((unsigned int)(BITS_PER_DWORD - STAT_BITS))	// number of bits used to store param
#define STATS_MAX_PARAMS				4								// maximum number of params for a stat
#define STATS_MAX_ATTACKS				3								// max number of cached attack lists
#define MAX_ACCRUE_TO					2								// max unit types to check for accrue to
#define SPEC_FUNC_PARAMS				5								// number of special function params per stat
#define MAX_FORMULA_STRLEN				4096							// max string length for formula, shouldn't exceed MAX_FIELD_LEN
#define MAX_REQUIREMENT_TYPES			2
#define STATSDISPLAY_NUM_CONDITIONS		3								// array size for conditions (statsdisplay.txt)
#define STATSDISPLAY_NUM_VALUES			4								// array size for values (statsdisplay.txt)
#define MAX_STAT_FUNCTION_NAME_LENGTH	(64)							// arbitrary

//----------------------------------------------------------------------------
#define STATS_TEST_MAGIC_RETURN(s)		ASSERT_RETURN(s->m_dwDebugMagic == STATS_DEBUG_MAGIC);
#define STATS_TEST_MAGIC_RETVAL(s, v)	ASSERT_RETVAL(s->m_dwDebugMagic == STATS_DEBUG_MAGIC, v);



//----------------------------------------------------------------------------
// ENUMERATIONS
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
// types of stats from stats.txt
enum STATSTYPE
{
	STATSTYPE_NONE,
	STATSTYPE_REGEN,
	STATSTYPE_FEED,
	STATSTYPE_REQUIREMENT,
	STATSTYPE_REQ_LIMIT,
	STATSTYPE_DEGEN_PERCENT,
	STATSTYPE_ALLOCABLE,
	STATSTYPE_MAX,
	STATSTYPE_MAX_RATIO,
	STATSTYPE_MAX_RATIO_DECREASE,
	STATSTYPE_MAX_PURE,
	STATSTYPE_DEGEN,
	STATSTYPE_REGEN_PERCENT,
	STATSTYPE_REGEN_CLIENT,
	STATSTYPE_DEGEN_CLIENT,
};


enum STATS_DATA_FLAGS
{
	STATS_DATA_NO_SET,													// this stat should never be set normally												bNoSet
	STATS_DATA_CURRENT_ONLY,											// this stat should never be modified by a dye											bCurrentOnly
	STATS_DATA_MODLIST,													// this stat can be on a mod list														bModListDebug
	STATS_DATA_VECTOR,													// this stat is a vector (float triplet)												bVectorDebug
	STATS_DATA_FLOAT,													// this stat is a float																	bFloat
	STATS_DATA_CALC_TARGET,												// this stat is calculated (ie. some formula changes this stat)							bCalcTarget
	STATS_DATA_ACCRUE,													// this stat accrues																	bAccrue
	STATS_DATA_ACCRUE_ONCE,												// this stat accrues, but only once														bAccrueOnceOnly
	STATS_DATA_COMBAT,													// combat stats don't get dyed until specifically applied								bCombat
	STATS_DATA_DIRECT_DAMAGE,											// direct damage stats that don't get copied to fields									bDirectDamage
	STATS_DATA_SEND_TO_SELF,											// send changes to owning client														bSendToSelf
	STATS_DATA_SEND_TO_ALL,												// send changes to all who know about this unit											bSendToAll
	STATS_DATA_SAVE,													// save the stat																		bSave
	STATS_DATA_SAVE_VAL_BY_CODE,										// use code to save value																bSaveValByCode
	STATS_DATA_NO_REACT_WHEN_DEAD,										// for stats that change the current when the max changes, if this is true the change cannot happen when the unit is dead		bNoMaxCurWhenDead
	STATS_DATA_STATE_CAN_MONITOR_CLIENT,								// does the client state system get a callback when this stat changes?					bStateCanMoniterClient
	STATS_DATA_STATE_CAN_MONITOR_SERVER,								// does the server state system get a callback when this stat changes?					bStateCanMoniterClient
	STATS_DATA_TRANSFER,												// whether or not to copy the stat on a call to StatsTransfer							bTransfer
	STATS_DATA_TRANSFER_TO_MISSILE,										// whether or not to transfer the stat to the missile on firing
	STATS_DATA_CALC_RIDER,												// whether to get the stat from the rider when we have both rider & unit in sStatsGetCalculatedStat		bRider
	STATS_DATA_ALWAYS_CALC,												// always calc this stat on read
	STATS_DATA_UPDATE_DATABASE,											// update the database when this stat changes											bUpdateDatabase
	STATS_DATA_DONT_TRANSFER_TO_NONWEAPON_MISSILE,						// whether or not to transfer the stat to the missile on firing if it is a nonweapon missile ( Mythos spells )
	STATS_DATA_RECALC_CUR_ON_SET,										// recalculate the cur stat when this stat is set	
	STATS_DATA_CLEAR_ON_ITEM_RESORE,									// restored items will clear this stat when they are created (if set)
	
	NUM_STATS_DATA_FLAGS
};

//----------------------------------------------------------------------------
// accrual methods
enum STATS_ACCRUAL_METHOD
{
	STATS_ACCRUAL_NONE = -1,
	STATS_ACCRUAL_SUM,
	STATS_ACCRUAL_MAX,
	STATS_ACCRUAL_MEAN,
};


//----------------------------------------------------------------------------
// special functionality to be called whenever we set certain types of stats
enum STATS_SPECFUNC
{
	STATSSPEC_NONE,
	STATSSPEC_REGEN_ON_GET,
	STATSSPEC_LINKED_REGEN,
	STATSSPEC_ALWAYS_CALC,
	STATSSPEC_PCT_REGEN_ON_GET,
	STATSSPEC_PCT_LINKED_REGEN,
};


//----------------------------------------------------------------------------
// tool tip location used for statsdisplay
enum STATS_DISPLAY_TOOLTIP_AREA
{
	SDTTA_OTHER = 0,
	SDTTA_HEADER,
	SDTTA_MOD,
	SDTTA_DAMAGE,
	SDTTA_ARMOR,
	SDTTA_LEVEL,
	SDTTA_PRICE,
	SDTTA_REQUIREMENTS,
	SDTTA_ITEMUNQIUE,
	SDTTA_INGREDIENT,
	SDTTA_ITEMTYPES,
	SDTTA_MODICONS,
	SDTTA_DPS,
	SDTTA_FEEDS,
	SDTTA_EXTRAS,
	SDTTA_USABLE,
	SDTTA_SFX,
	SDTTA_WEAPONSTATS,
	SDTTA_AFFIXPROPS,
	SDTTA_OTHERPROPSHDR,
	SDTTA_OTHERPROPS,
	SDTTA_MODLIST,
	SDTTA_DEFENSE,
	SDTTA_MELEESPEED,
	SDTTA_ABOVEHEAD,
	SDTTA_NONE,
};


//----------------------------------------------------------------------------
// stats func application
enum STATSFUNC_APP
{
	STATSFUNC_APP_BOTH,
	STATSFUNC_APP_HELLGATE,
	STATSFUNC_APP_MYTHOS,
};

//----------------------------------------------------------------------------
static enum STATS_GUID_PARAM
{
	GUID_PARAM_LOW = 0,		// do not change w/o versioning, saved in unit files
	GUID_PARAM_HIGH = 1,	// do not change w/o versioning, saved in unit files
};

//----------------------------------------------------------------------------
enum STATS_SPLIT_64BIT_VALUE_PARAM
{
	SPLIT_VALUE_64_PARAM_LOW = 0,	// do not change w/o versioning, saved in unit files
	SPLIT_VALUE_64_PARAM_HIGH = 1,	// do not change w/o versioning, saved in unit files
};

//----------------------------------------------------------------------------
enum REQUIREMENT_FAIL_APP
{
	RFA_INVALID = -1,
	
	RFA_ALL,
	RFA_HELLGATE,
	RFA_MYTHOS,
	
	NUM_REQUIREMENT_FAIL
};


//----------------------------------------------------------------------------
// TYPEDEF
//----------------------------------------------------------------------------
typedef DWORD							PARAM;
typedef unsigned int					STATS_VERSION;
// callback for when a timed statslist gets removed
typedef void FP_STATSREMOVECALLBACK(struct GAME * game, struct UNIT * unit, struct STATS * stats);


//----------------------------------------------------------------------------
// MACROS
//----------------------------------------------------------------------------
#define PARAM_MASK						((1 << PARAM_BITS) - 1)
#define MAKE_STAT(s, p)					(((s) << PARAM_BITS) + ((p) & PARAM_MASK))
#define STAT_GET_STAT(d)				((WORD)((unsigned int)(d) >> PARAM_BITS))
#define STAT_GET_PARAM(d)				(PARAM)((unsigned int)(d) & PARAM_MASK)
#define INVALID_PARAM					(PARAM)((INVALID_ID) & PARAM_MASK)

#define STATS_ITERATE_STATS_RANGE(stats, stat, list, iter, size)		{ int UIDEN(STAT_COUNT) = size; int UIDEN(STAT_CPARA) = 0; \
																			while (UIDEN(STAT_COUNT) >= size) { \
																			STATS_ENTRY list[size]; UIDEN(STAT_COUNT) = \
																			StatsGetRange(stats, stat, UIDEN(STAT_CPARA), list, size); \
																			UIDEN(STAT_CPARA) = ((UIDEN(STAT_COUNT) >= size && list[size-1].GetParam() < USHRT_MAX)\
																			? list[size-1].GetParam() + 1 : 0); \
																			for (int iter = 0; iter < UIDEN(STAT_COUNT); iter++) {
#define STATS_ITERATE_STATS_END		} } }
#define UNIT_ITERATE_STATS_RANGE(unit, stat, list, iter, size)			{ int UIDEN(STAT_COUNT) = size; int UIDEN(STAT_CPARA) = 0; \
																			while (UIDEN(STAT_COUNT) >= size) { \
																			STATS_ENTRY list[size]; UIDEN(STAT_COUNT) = \
																			UnitGetStatsRange(unit, stat, UIDEN(STAT_CPARA), list, size); \
																			UIDEN(STAT_CPARA) = ((UIDEN(STAT_COUNT) >= size && list[size-1].GetParam() < USHRT_MAX) \
																			? list[size-1].GetParam() + 1 : 0); \
																			for (int iter = 0; iter < UIDEN(STAT_COUNT); iter++) {
#define UNIT_ITERATE_STATS_END		} } }


//----------------------------------------------------------------------------
// DATA STRUCTURES
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
// calc node for stats calc
//----------------------------------------------------------------------------
struct STATS_CALC
{
	unsigned int						m_nToken;						// STATS_TOKEN
	int									m_nTokIdx;						// data param for STATS_TOKEN
	unsigned int						m_nChildren;					// number of children
	STATS_CALC *						m_Parent;						// parent
	STATS_CALC *						m_ChildFirst;					// head of child list
	STATS_CALC *						m_ChildLast;					// tail of child list
	STATS_CALC *						m_Prev;							// previous sibling
	STATS_CALC *						m_Next;							// next sibling
};


//----------------------------------------------------------------------------
// each stat has a list of these for each formula it's involved in
//----------------------------------------------------------------------------
struct STATS_CALC_AFFECTS
{
	const STATS_CALC *					m_Calc;							// pointer to intermediate calc node
	int									m_nStatsFunc;					// stats function index
	int									m_nTargetStat;					// cached target stat from m_Calc
	int									m_nControlUnitType;				// copy of relevant fields from STATS_FUNCTION
	PCODE								m_codeControlCode;				// 
};

//----------------------------------------------------------------------------
typedef enum STAT_VERSION_RESULT (* PFN_STAT_VERSION_FUNCTION)(struct STATS_FILE &tStatsFile, STATS_VERSION &nStatsVersion, struct UNIT *pUnit);


//----------------------------------------------------------------------------
// data to pass into FP_STATSCHANGECALLBACK set on initialization
//----------------------------------------------------------------------------
struct STATS_CALLBACK_DATA
{
	DWORD								m_dwData1;

	STATS_CALLBACK_DATA(
		void) : m_dwData1(INVALID_ID)
	{
	}

	STATS_CALLBACK_DATA(
		unsigned int data1) : m_dwData1(data1)
	{
	}
};

//----------------------------------------------------------------------------
// callback for when a stat changes
//----------------------------------------------------------------------------
typedef void FP_STATSCHANGECALLBACK(struct UNIT * unit, int wStat, PARAM dwParam, int oldvalue, int newvalue, const STATS_CALLBACK_DATA & data, BOOL bSend);

//----------------------------------------------------------------------------
// for each stat, list the callbacks to call when it changes
//----------------------------------------------------------------------------
struct STATS_CALLBACK_TABLE
{
	FP_STATSCHANGECALLBACK *			m_fpCallback;
	STATS_CALLBACK_DATA					m_Data;
	STATS_CALLBACK_TABLE *				m_pNext;
};

//----------------------------------------------------------------------------
// stats.txt entries
//----------------------------------------------------------------------------
struct STATS_DATA
{
	char								m_szName[STATS_NAME_SIZE];		// str index in stats.xls
	WORD								m_wCode;						// 2 letter code used for saving
	int									m_nStatsType;					// enum, type of stat
	int									m_nAssociatedStat[STATS_NUM_ASSOCATED];	// associated stats used by various stat types (for regen etc)
	int									m_nRegenIntervalInMS;			// how often to update this stat
	int									m_nRegenDivisor;				// divide regen by this amount as a magic number
	int									m_nRegenDelayOnDec;				// if the stat gets decremented, how long before it starts to regen?
	int									m_nRegenDelayOnZero;			// if the stat reaches zero, how long before it starts to regen?
	int									m_nMonsterRegenDelay;			// for monsters, the regen delay = delay * 100 / (100 + modifier)
	int									m_nRegenByStat[STATS_NUM_ASSOCATED];	// stat which regens this stat
	int									m_nStatOffset;					// add this value before storing it (used when default is -1 instead of 0)
	int									m_nShift;						// this is the shift-value for the stat (for integral franctions)
	int									m_nMinSet;						// constant min for the stat (default INT_MIN)
	int									m_nMaxSet;						// constant max for the stat (default -1)
	int									m_nMaxStat;						// link to stat which is the max
	int									m_nMinAssert;					// assert when the stat accrues to less than this
	int									m_nMaxAssert;					// assert when the stat accrues to more than this
	int									m_nAccrualMethod;				// accrual method
	int									m_nAccrueTo[MAX_ACCRUE_TO];		// type of unit to accrue on
	int									m_nUnitType;					// stat only applies to this unit type
	DWORD								m_dwFlags[DWORD_FLAG_SIZE(NUM_STATS_DATA_FLAGS)];		// flags
	BOOL								m_bUnitTypeDebug[NUM_GENUS];	// assert if we try to set a stat on a unit it doesn't belong on
	int									m_nValBits;						// number of bits used to encode the value of this stat
	int									m_nValBitsWindow;				// for bitfields; how many bits of data each value actually uses
	int									m_nValBitsFile;					// as above, but when saved to file
	int									m_nValShift;					// counter shift, because we don't need to send high precision to client
	int									m_nValOffs;						// offset the value to encode to client
	int									m_nValTable;					// what the value means (which datatable it points to)
	unsigned int						m_nTotalParamBits;				// total number of bits of all params
	unsigned int						m_nParamCount;					// number of params
	unsigned int						m_nParamBits[STATS_MAX_PARAMS];	// number of bits used to encode the param for this stat
	unsigned int						m_nParamBitsFile[STATS_MAX_PARAMS];		// as above, but when saved to file
	unsigned int						m_nParamShift[STATS_MAX_PARAMS];		// number of bits to shift the param by
	unsigned int						m_nParamOffs[STATS_MAX_PARAMS];	// offset the param by this value
	int									m_nParamTable[STATS_MAX_PARAMS];		// what the param means (which datatable it points to)
	unsigned int						m_nParamGetShift[STATS_MAX_PARAMS];		// shift & mask are a pair of values which isolate the param from a stat-param pair
	unsigned int						m_nParamGetMask[STATS_MAX_PARAMS];		// via (val >> nParamGetShift[n]) & nParamGetMask[n]
	int									m_nMinTicksBetweenDatabaseCommits;	// some stats are not saved every time they change, they are saved on an interval
	enum DBUNIT_FIELD					m_eDBUnitField;					// when some stats save to the DB, they are capable of using a field directly in the db unit structure (instead of putting the data only inside the binary blob)
	
	int									m_nSpecialFunction;				// special stat handling functionality (regen, etc)
	int									m_nSpecFuncStat[SPEC_FUNC_PARAMS];		// parameter stats for nSpecialFunction

	SAFE_PTR(STATS_CALC_AFFECTS*,		m_FormulaAffectsList);			// formulas this stat affects
	unsigned int						m_nFormulaAffectsList;			// count of m_pnFormulaAffectsList

	SAFE_PTR(unsigned int*,				m_FormulaAffectedByList);		// formulas that target this stat
	unsigned int						m_nFormulaAffectedByList;		// count of pnFormulaAffectedByList

	int									m_nReqirementTypes[MAX_REQUIREMENT_TYPES];				// types of unit to check requirements (feed, etc) against
	int									m_nRequirementFailString[NUM_REQUIREMENT_FAIL];			// a string we can display if something fails a requirement check
	
	SAFE_PTR(STATS_CALLBACK_TABLE*,		m_SvrStatsChangeCallback);		// callback when stat changes
	SAFE_PTR(STATS_CALLBACK_TABLE*,		m_CltStatsChangeCallback);		// callback when stat changes

	char								szVersionFunction[MAX_STAT_FUNCTION_NAME_LENGTH];
	SAFE_FUNC_PTR(PFN_STAT_VERSION_FUNCTION, pfnVersion);
};


//----------------------------------------------------------------------------
// additional computed stats table info
//----------------------------------------------------------------------------
struct STATS_DATAEX
{
	int *								m_pnCombatStats;				// list of combat stats
	unsigned int						m_nCombatStats;					// number of combat stats
	int *								m_pnFeedStats;					// list of feed stats
	unsigned int						m_nFeedStats;					// number of feed stats
	int *								m_pnRequirementStats;			// list of requirement stats
	unsigned int						m_nRequirementStats;			// number of requirement stats
	int *								m_pnRequirementLimitStats;		// list of requirement limit stats
	unsigned int						m_nRequirementLimitStats;		// number of requirement limit stats
};


//----------------------------------------------------------------------------
// statsfunc.txt entries
//----------------------------------------------------------------------------
struct STATS_FUNCTION
{
	int									m_nTargetStat;					// ultimate target of the function
	int									m_nApp;							// application
	int									m_nControlUnitType;				// applies only to this unit type
	PCODE								m_codeControlCode;				// more specific control of whether or not to use this function
	char								m_szCalc[MAX_FORMULA_STRLEN];	// formula string
	SAFE_PTR(STATS_CALC*,				m_Calc);							// full calc tree for this function
};

//----------------------------------------------------------------------------
struct STATS_SELECTOR_DATA
{
	char								szName[DEFAULT_INDEX_SIZE];
	WORD								wCode;
};


//----------------------------------------------------------------------------
// stats are essentially variables which normally contain 32-bit int values
// each stat is comprised of a STAT_BITS stat index into stats.txt
// and up to STATS_MAX_PARAMS params as defined by its entry in stats.txt
// whose total bit-count is no more than PARAM_BITS
//----------------------------------------------------------------------------
#include <PshPack4.h>
struct STATS_ENTRY
{
	DWORD		stat;
	int			value;

	WORD GetStat(
		void) const
	{
		return STAT_GET_STAT(stat);
	}
	PARAM GetParam(
		void) const
	{
		return STAT_GET_PARAM(stat);
	}
};
#include "PopPack.h"


//----------------------------------------------------------------------------
// statsdisplay enums
//----------------------------------------------------------------------------
enum DISPLAY_VALUE_CONTROL
{
	DISPLAY_VALUE_CONTROL_SCRIPT_VALUE_NOPRINT = 0,		
	DISPLAY_VALUE_CONTROL_SCRIPT,					
	DISPLAY_VALUE_CONTROL_SCRIPT_PLUSMINUS,				
	DISPLAY_VALUE_CONTROL_SCRIPT_PLUSMINUS_NOZERO,		
	DISPLAY_VALUE_CONTROL_UNIT_NAME,				
	DISPLAY_VALUE_CONTROL_UNIT_CLASS,			
	DISPLAY_VALUE_CONTROL_UNIT_GUILD,
	DISPLAY_VALUE_CONTROL_STAT_PARAM_STRING,		
	DISPLAY_VALUE_CONTROL_STAT_VALUE,			
	DISPLAY_VALUE_CONTROL_PLUSMINUS,				
	DISPLAY_VALUE_CONTROL_PLUSMINUS_NOZERO,		
	DISPLAY_VALUE_CONTROL_UNIT_TYPE,
	DISPLAY_VALUE_CONTROL_UNIT_TYPE_LASTONLY,
	DISPLAY_VALUE_CONTROL_UNIT_TYPE_QUALITY,				
	DISPLAY_VALUE_CONTROL_UNIT_ADDITIONAL,
	DISPLAY_VALUE_CONTROL_AFFIX,					
	DISPLAY_VALUE_CONTROL_FLAVOR,				
	DISPLAY_VALUE_CONTROL_SCRIPT_DIVIDE_BY_100,	
	DISPLAY_VALUE_CONTROL_SCRIPT_DIVIDE_BY_10,	
	DISPLAY_VALUE_CONTROL_SCRIPT_DIVIDE_BY_20,	
	DISPLAY_VALUE_CONTROL_STAT_PARAM_STRING_PLURAL,	
	DISPLAY_VALUE_CONTROL_ITEM_QUALITY,				
	DISPLAY_VALUE_CONTROL_CLASS_REQUIREMENTS,		
	DISPLAY_VALUE_CONTROL_FACTION_REQUIREMENTS,
	DISPLAY_VALUE_CONTROL_SKILLGROUP,
	DISPLAY_VALUE_CONTROL_ITEM_UNIQUE,
	DISPLAY_VALUE_CONTROL_ITEM_INGREDIENT,
	DISPLAY_VALUE_CONTROL_AFFIX_PROPS_LIST,
	DISPLAY_VALUE_CONTROL_INV_ITEM_PROPS,
	DISPLAY_VALUE_CONTROL_ITEM_DMG_DESC,
	DISPLAY_VALUE_CONTROL_CREATED_BY
};

enum DISPLAY_FUNCTION
{
	DISPLAY_FUNCTION_FORMAT,
	DISPLAY_FUNCTION_INVENTORY,
};

enum DISPLAY_CONTROL
{
	DISPLAY_CONTROL_SINGLE = -1,	// needs to be the default 
	DISPLAY_CONTROL_PARAM_RANGE,
};


//----------------------------------------------------------------------------
// statsdisplay.txt table entries
//----------------------------------------------------------------------------
struct STATS_DISPLAY
{
	char								szName[DEFAULT_INDEX_SIZE];
	char								szDebugName[DEFAULT_INDEX_SIZE];
	BOOL								bRider;
	int									nDisplayRule[STATSDISPLAY_NUM_CONDITIONS];
	BOOL								bIncludeUnitInCondition[STATSDISPLAY_NUM_CONDITIONS];
	PCODE								codeDisplayCondition[STATSDISPLAY_NUM_CONDITIONS];
	int									bNewLine;
	int									nFormatString;
	int									nShortFormatString;
	int									nShortDescripString;
	char								szIconFrame[DEFAULT_FILE_SIZE];
	int									nDisplayControlStat;
	DISPLAY_CONTROL						eDisplayControl;
	DISPLAY_FUNCTION					eDisplayFunc;
	DISPLAY_VALUE_CONTROL				peValueCtrl[STATSDISPLAY_NUM_VALUES];
	PCODE								codeValue[STATSDISPLAY_NUM_VALUES];
	int									nTooltipArea;
	int									nToolTipText;
	PCODE								codeColor;
};


//----------------------------------------------------------------------------
// EXPORTED FUNCTIONS
//----------------------------------------------------------------------------
// export to excel to parse dynamic stats headers
BOOL StatsParseToken(
	const char * token,
	int & wStat,
	DWORD & dwParam);

// post index function
BOOL ExcelStatsPostIndex(
	struct EXCEL_TABLE * table);

// post process function
BOOL ExcelStatsPostProcess(
	struct EXCEL_TABLE * table);

// called after all tables have been loaded (both cooked and raw)
BOOL ExcelStatsPostLoadAll(
	struct EXCEL_TABLE * table);

// called after all tables have been loaded (both cooked and raw)
BOOL ExcelStatsFuncPostLoadAll(
	struct EXCEL_TABLE * table);

// excel row free function for stats.txt
void ExcelStatsRowFree(
	EXCEL_TABLE * table,
	BYTE * rowdata);

// excel row free function for statsfunc.txt
void ExcelStatsFuncRowFree(
	EXCEL_TABLE * table,
	BYTE * rowdata);

// add a stats change callback
void StatsAddStatsChangeCallback(
	STATS_DATA * stats_data,
	FP_STATSCHANGECALLBACK * fpCallback,
	const STATS_CALLBACK_DATA & data,
	BOOL bServer,
	BOOL bClient);

// add a stats change callback
void StatsAddStatsChangeCallback(
	int stat,
	FP_STATSCHANGECALLBACK * fpCallback,
	const STATS_CALLBACK_DATA & data,
	BOOL bServer,
	BOOL bClient);

// create a stats list for a unit, set delta callback if applicable
void UnitStatsInit(
	struct UNIT * unit);

// free a unit's statslist
void UnitStatsFree(
	struct UNIT * unit);

// get the value for a stat/param of a stat list
int StatsGetStat(
	STATS * stats,
	int wStat,
	PARAM dwParam = 0);

// get the value for a stat/param of a stat list
// shift the value right by nShift from STATS_DATA
int StatsGetStatShift(
	GAME * game,
	STATS * stats,
	int wStat,
	PARAM dwParam = 0);

// this is specifically used by max/ratio stats callbacks that need to get the stat prior to applying a min/max component
int UnitGetStatDontApplyMinMax(
	UNIT * unit,
	int wStat,
	PARAM dwParam = 0);

// get the current value for a stat/param of a unit
int UnitGetStat(
	struct UNIT * unit,
	int wStat,
	PARAM dwParam = 0);

// get the current value for a stat/param of a unit
int UnitGetStat(
	struct UNIT * unit,
	int wStat,
	PARAM dwParam1,
	PARAM dwParam2);

// get the current value for a stat/param of a unit
int UnitGetStat(
	struct UNIT * unit,
	int wStat,
	PARAM dwParam1,
	PARAM dwParam2,
	PARAM dwParam3);

int UnitGetStatRegen(
	UNIT * unit,
	int wStat,
	PARAM dwParam = 0);

int UnitGetBitfieldStat(
	struct UNIT* unit,
	int wStat,
	PARAM dwParam1 );

int UnitGetBitfieldStat(
	struct UNIT* unit,
	int wStat,
	PARAM dwParam1,
	PARAM dwParam2 );

int UnitGetBitfieldStat(
	struct UNIT* unit,
	int wStat,
	PARAM dwParam1,
	PARAM dwParam2,
	PARAM dwParam3 );

// gets the stat from m_Accr
int UnitGetAccruedStat(
	UNIT * unit,
	int wStat,
	PARAM dwParam = 0);

// get the accrued value for a stat/param of a unit
// shift the value right by nShift from STATS_DATA
int UnitGetStatShift(
	struct UNIT * unit,
	int wStat,
	PARAM dwParam = 0);

// get the base value for a stat of a unit
int UnitGetBaseStat(
	struct UNIT * unit,
	int wStat,
	PARAM dwParam = 0);

// get the base value for a stat of a unit
// shift the value right by nShift from STATS_DATA
int UnitGetBaseStatShift(
	struct UNIT * unit,
	int wStat,
	PARAM dwParam = 0);

// get the accrued-base value for a stat/param of a unit
int UnitGetModStat(
	struct UNIT * unit,
	int wStat,
	PARAM dwParam = 0);

// get the accrued-base value for a stat/param of a unit
// shift the value right by nShift from STATS_DATA
int UnitGetModStatShift(
	struct UNIT * unit,
	int wStat,
	PARAM dwParam = 0);

// return the value of a stat, fully calculating it
int StatsGetCalculatedStat(
	UNIT * unit,
	int objecttype,
	STATS * stats,
	int wStat,
	PARAM dwParam = 0);

// return the value of a stat, fully calculating it
int StatsGetCalculatedStatShift(
	UNIT * unit,
	int objecttype,
	STATS * stats,
	int wStat,
	PARAM dwParam = 0);

// set the current stat value for a free-standing statlist
void StatsSetStat(
	GAME * game,
	STATS * stats,
	int wStat,
	int nValue);

// set the current stat/param value for a free-standing statlist
void StatsSetStat(
	GAME * game,
	STATS * stats,
	int wStat,
	PARAM dwParam,
	int nValue);

// set the current stat value for a free-standing statlist
// shift the value left by nShift from STATS_DATA
void StatsSetStatShift(
	GAME * game,
	STATS * stats,
	int wStat,
	int nValue);

// set the current stat/param value for a free-standing statlist
// shift the value left by nShift from STATS_DATA
void StatsSetStatShift(
	GAME * game,
	STATS * stats,
	int wStat,
	PARAM dwParam,
	int nValue);

// set the base stat value for a unit (param == 0)
// note: we should assert that this is a 0 param stat as spec'd by stats.txt
void UnitSetStat(
	struct UNIT * unit,
	int wStat,
	int nValue);

// set the base stat/param value for a unit
void UnitSetStat(
	struct UNIT * unit,
	int wStat,
	PARAM dwParam,
	int nValue);

// set state for multi param stat
void UnitSetStat(
	struct UNIT * unit,
	int wStat,
	PARAM dwParam1,
	PARAM dwParam2,
	int nValue);

// set state for multi param stat
void UnitSetStat(
	struct UNIT * unit,
	int wStat,
	PARAM dwParam1,
	PARAM dwParam2,
	PARAM dwParam3,
	int nValue);

void UnitSetBitfieldStat(
struct UNIT* unit,
	int wStat,
	PARAM dwParam1,
	int value);

void UnitSetBitfieldStat(
struct UNIT* unit,
	int wStat,
	PARAM dwParam1,
	PARAM dwParam2,
	int value);

void UnitSetBitfieldStat(
struct UNIT* unit,
	int wStat,
	PARAM dwParam1,
	PARAM dwParam2,
	PARAM dwParam3,
	int value);



// set a GUID stat (automatically breaks it up with params for the GUID parts)
void UnitSetGUIDStat(
	struct UNIT * unit,
	int wStat,
	PGUID guid);

// get GUID stat
PGUID UnitGetGUIDStat(
	struct UNIT * unit,
	int wStat);
	
// set the base stat value for a unit (param == 0)
// note: we should assert that this is a 0 param stat as spec'd by stats.txt
void UnitSetStatNoSend(
	struct UNIT * unit,
	int wStat,
	int nValue);

// set the base stat value for a unit (param == 0)
// note: we should assert that this is a 0 param stat as spec'd by stats.txt
// shift the value left by nShift from STATS_DATA
void UnitSetStatShift(
	struct UNIT * unit,
	int wStat,
	int nValue);

// set the base stat/param value for a unit
// shift the value left by nShift from STATS_DATA
void UnitSetStatShift(
	struct UNIT * unit,
	int wStat,
	PARAM dwParam,
	int nValue);

// note: we should assert that this is a 0 param stat as spec'd by stats.txt
// shift the value left by nShift from STATS_DATA
void UnitSetStatShiftNoSend(
	struct UNIT * unit,
	int wStat,
	int nValue);

// set the base stat/param value for a unit
// shift the value left by nShift from STATS_DATA
void UnitSetStatShiftNoSend(
	struct UNIT * unit,
	int wStat,
	PARAM dwParam,
	int nValue);

// add a delta to the stat for a statslist
void StatsChangeStat(
	GAME * game,
	STATS * stats,
	int wStat,
	int nDelta);

// add a delta to the stat/param for a statslist
void StatsChangeStat(
	GAME * game,
	STATS * stats,
	int wStat,
	PARAM dwParam,
	int nDelta);

// add a delta to the stat for a statslist
// shift the value left by nShift from STATS_DATA
void StatsChangeStatShift(
	GAME * game,
	STATS * stats,
	int wStat,
	int nDelta);

// add a delta to the stat/param for a statslist
// shift the value left by nShift from STATS_DATA
void StatsChangeStatShift(
	GAME * game,
	STATS * stats,
	int wStat,
	PARAM dwParam,
	int nDelta);

// add a delta to the base stat for a unit
void UnitChangeStat(
	struct UNIT * unit,
	int wStat,
	int nDelta);

// add a delta to the base stat/param for a unit
void UnitChangeStat(
	struct UNIT * unit,
	int wStat,
	PARAM dwParam,
	int nDelta);

// add a delta to the base stat for a unit
// shift the value left by nShift from STATS_DATA
void UnitChangeStatShift(
	struct UNIT * unit,
	int wStat,
	int nDelta);

// add a delta to the base stat/param for a unit
// shift the value left by nShift from STATS_DATA
void UnitChangeStatShift(
	struct UNIT * unit,
	int wStat,
	PARAM dwParam,
	int nDelta);

// clear the stat in a statslist
void StatsClearStat(
	GAME * game,
	STATS * stats,
	int wStat,
	PARAM dwParam);

// clear the stat for a unit
void UnitClearStat(
	UNIT * unit,
	int wStat,
	PARAM dwParam);

// clear the stat for a unit (all entries for all params)
void UnitClearStatAll(
	UNIT * unit,
	int wStat);
	
STATS * StatsListInit(
	GAME * game);

// free a free-standing statslist, NOT a unit's statslist
void StatsListFree(
	GAME * game,
	STATS * stats);

// remove a statslist from its parent
void StatsListRemove(
	GAME * game,
	STATS * dye);

// remove a unit's statslist from its parent
void StatsListRemove(
	struct UNIT * dye);

STATS * StatsListAddRider(
	GAME * game,
	STATS * stats,
	int selector);

STATS_SELECTOR StatsGetSelector(
	const STATS * stats);

// get the unit this unit is currently modifying
UNIT * StatsGetParent(
	const struct UNIT * unit);

// get the unit this statslist is currently modifying
UNIT * StatsGetParent(
	const STATS * stats);

// is the dye unit attached to cloth or cloth of cloth, etc
BOOL UnitIsInDyeChain(
	const UNIT * cloth,
	const UNIT * dye);

// get the first occurrence of a statlist, given the selector, modifying a unit
// a zero selector will get all lists
STATS * StatsGetModList(
	const struct UNIT * unit,
	int selector = 0);

// get the next occurrence of a statlist, given the selector, modifying a unit
STATS * StatsGetModNext(
	STATS * stats,
	int selector = 0);

// get number of stats in stats list
int StatsGetCount(
	const STATS * stats);

// copy stats list items to array
unsigned int StatsListGetEntries(
	const STATS * stats,
	STATS_ENTRY * statsentries,
	unsigned int size);

// iterate all of the stats in a statslist
typedef void (*PFN_STATSLIST_ITERATE)(const STATS_ENTRY *, void*);
void StatsListIterate(
	const STATS * stats,
	PFN_STATSLIST_ITERATE pfnStatsListIterate,
	void *userdata);

// fills in an array with the values of stat/param=x of a statslist
int StatsGetRange(
	STATS * stats,
	int wStat,
	PARAM dwParam,
	STATS_ENTRY * statslist,
	int size);

// fills in an already partially-filled array with the values of stat/param=x of a statslist
int StatsGetRange(
	STATS * stats,
	int wStat,
	PARAM dwParam,
	STATS_ENTRY * statslist,
	int nStartingCount,
	int size);

// fills in an array with the current values of stat/param=x of a unit
int UnitGetStatsRange(
	struct UNIT * unit,
	int wStat,
	PARAM dwParam,
	STATS_ENTRY * statslist,
	int size);

// fills in an already partially-filled array with the current values of stat/param=x of a unit
int UnitGetStatsRange(
	struct UNIT * unit,
	int wStat,
	PARAM dwParam,
	STATS_ENTRY * statslist,
	int nStartingCount,
	int size);

// fills in an array with the base values of stat/param=x of a unit
int UnitGetStatsRangeBase(
	struct UNIT * unit,
	int wStat,
	PARAM dwParam,
	STATS_ENTRY * statslist,
	int size);

// clear a stat in a statlist
void StatsClearRange(
	GAME * game,
	STATS * stats,
	int wStat);

// clear a unit's base stats for wStat
void UnitClearStatsRange(
	UNIT * unit,
	int wStat);

// get the first stat entry with this stat of any param
int StatsGetStatAny(
	STATS * stats,
	int wStat,
	PARAM * pdwParam);

// get the first stat entry with this stat of any param
int UnitGetStatAny(
	UNIT * unit,
	int wStat,
	PARAM * pdwParam);

// get the sum of a stat / param range
int StatsGetTotal(
	STATS * stats,
	int wStat);
	
// get the sum of a stat / param range
int UnitGetStatsTotal(
	struct UNIT * unit,
	int wStat);

// get the base sum of a stat / param range
int UnitGetBaseStatsTotal(
struct UNIT * unit,
	int wStat);
	
// wraps UnitGetStat using typecasts to store the floats - assumes that wStat is the first of three stats used for a vector
VECTOR UnitGetStatVector( 
	UNIT * unit,
	int wStat,
	PARAM dwParam);

// wraps UnitGetStat using typecasts to store the floats
VECTOR UnitGetStatVector( 
	UNIT * unit,
	int wStat,
	PARAM dwParam,
	PARAM dwParam2);

// wraps UnitGetStat using typecasts to store the floats
VECTOR UnitGetStatVector( 
	UNIT * unit,
	int wStat,
	PARAM dwParam,
	PARAM dwParam2,
	PARAM dwParam3);

// wraps UnitSetStat using typecasts to store the floats - assumes that wStat is the first of three stats used for a vector
void UnitSetStatVector( 
	UNIT * unit,
	int wStat,
	PARAM dwParam,
	const VECTOR& vValue);

// wraps UnitSetStat using typecasts to store the floats
void UnitSetStatVector( 
	UNIT * unit,
	int wStat,
	PARAM dwParam,
	PARAM dwParam2,
	const VECTOR& vValue);

// wraps UnitSetStat using typecasts to store the floats
void UnitSetStatVector( 
	UNIT * unit,
	int wStat,
	PARAM dwParam,
	PARAM dwParam2,
	PARAM dwParam3,
	const VECTOR& vValue);

// wraps UnitGetStat using typecasts to store the floats - assumes that wStat is the first of three stats used for a vector
VECTOR StatsGetStatVector( 
	GAME * game,
	STATS * pStats,
	int wStat,
	PARAM dwParam);

// wraps UnitSetStat using typecasts to store the floats - assumes that wStat is the first of three stats used for a vector
void StatsSetStatVector( 
	GAME * game,
	STATS * pStats,
	int wStat,
	PARAM dwParam,
	const VECTOR& vValue);

// wraps UnitGetStat using typecasts to store the floats
float UnitGetStatFloat( 
	UNIT * unit,
	int wStat,
	PARAM dwParam = 0);

// wraps UnitSetStat using typecasts to store the floats
void UnitSetStatFloat( 
	UNIT * unit,
	int wStat,
	PARAM dwParam,
	float fValue);

// wraps StatsSetStat using typecasts to store the floats
void StatsSetStatFloat( 
	GAME * game,
	STATS * pStats,
	int wStat,
	PARAM dwParam,
	float fValue);

// wraps StatsGetStat using typecasts to store the floats
float StatsGetStatFloat( 
	GAME * game,
	STATS * pStats,
	int wStat,
	PARAM dwParam);

// for shifted stats it converts the stat to a float
float StatsGetAsFloat( 
	int wStat,
	int nStatValueAsInt );

// for shifted stats it converts the stat from a float to an int with the proper fraction
int StatsGetAsShiftedInt( 
	int wStat,
	float fStatValueAsFloat );

// test a bit on a flags-type stat
BOOL UnitStatTestBit(
	UNIT * unit,
	int wStat,
	PARAM dwParam,
	unsigned int bit);

// set a bit on a flags-type stat
void UnitStatSetBit(
	UNIT * unit,
	int wStat,
	PARAM dwParam,
	unsigned int bit);

// clear a bit on a flags-type stat
void UnitStatClearBit(
	UNIT * unit,
	int wStat,
	PARAM dwParam,
	unsigned int bit);

// attach a statslist to a unit
// filter is used to determine an application set (such as weapon stats)
// selector is used to aid searching through stats lists
void StatsListAdd(
	struct UNIT * cloth,
	STATS * dye,
	BOOL bSend,
	int selector = 0,
	int filter = 0);

// attach a unit's statslist to a unit
void StatsListAdd(
	struct UNIT * cloth,
	struct UNIT * dye,
	BOOL bCombat,
	int filter = 0);

// apply weapon stats from dye to cloth
void StatsListApplyWeaponStats(
	UNIT * cloth,
	UNIT * dye);

// remove weapon stats from dye from cloth
void StatsListRemoveWeaponStats(
	UNIT * cloth,
	UNIT * dye);

// return true if statslist is a rider
BOOL StatsIsRider(
	const STATS * stats);

// get the next (or first) rider
STATS * StatsGetRider(
	const STATS * stats,
	const STATS * rider = NULL);

// get the next (or first) rider
STATS * UnitGetRider(
	UNIT * unit,
	STATS * rider);

// make a copy of all riders and place on unit
void UnitCopyRidersToUnit(
	UNIT * source,
	UNIT * target,
	int selector);

// clear the expiration timer for a timered statslist
void StatsClearTimer(
	GAME * game,
	UNIT * cloth,
	STATS * stats);

// set the expiration timer for a timered statslist, it must already be attached to stats
void StatsSetTimer(
	GAME * game,
	UNIT * cloth,
	STATS * stats,
	int lengthInTicks);

unsigned int StatsGetTimer(
	GAME * game,
	STATS * stats); 

// set a callback function to call when the statslist is removed
void StatsSetRemoveCallback(
	GAME * game,
	STATS * stats,
	FP_STATSREMOVECALLBACK fpRemoveCallback);

// add a new timed modlist
DWORD StatsListAddTimed(
	UNIT * cloth,
	STATS * dye,
	int selector,
	int filter,
	int lengthInTicks,
	FP_STATSREMOVECALLBACK fpRemoveCallback,
	BOOL bSend);

// transfers the accrued list from dye to the current for cloth according to bTransfer
void StatsTransfer(
	UNIT * cloth,
	UNIT * dye);

// transfers the accrued list from dye to the current for cloth according to bTransfer
void StatsTransferAdd(
	GAME * game,
	STATS * cloth,
	UNIT * dye);

// transfers the accrued list from dye to the current for cloth according to bTransfer
void StatsTransferAdd(
	GAME * game,
	UNIT * cloth,
	STATS * dye);

// transfers the accrued list from dye to the current for cloth according to bTransfer
void StatsTransferSet(
	GAME * game, 
	STATS * cloth,
	UNIT * dye);

// check if requirements for a stat apply to the unit type of the container
BOOL StatsCheckRequirementType(
	UNIT * container,
	const STATS_DATA * stats_data);
			
// create a display string based on a unit & stats list
BOOL PrintStats(
	GAME * game,
	EXCELTABLE eDisplayTable, 
	int nDisplayArea,
	UNIT * unit,
	WCHAR * str,	
	int len,
	STATS * stats = NULL,
	const WCHAR * stringWrapper = NULL ); //encompasses the stat that is getting printed

//tugboat only, prints stats for unittypes.
BOOL PrintStatsForUnitTypes( 
	GAME * game,
	EXCELTABLE eDisplayTable, 
	int nDisplayArea,
	UNIT * unit,
	WCHAR * str,
	WCHAR * tmpStr,
	int len );

// print a single stats line
BOOL PrintStatsLine(
	GAME * game,
	EXCELTABLE eDisplayTable, 
	int line,
	struct DISPLAY_CONDITION_RESULTS * results,
	UNIT * unit,
	WCHAR * szLine,
	int len,
	int nDisplayArea,
	BOOL bPrintRider);

// print a single stats icon
BOOL PrintStatsLineIcon(
	GAME * game,
	EXCELTABLE eDisplayTable, 
	int line,
	UNIT * unit,
	STATS * stats,
	WCHAR * szIconText,
	int nIconTextLen,
	WCHAR* szDescripText,
	int nDescripTextLen,
	CHAR * szIconFrame,
	int nIconFrameLen);

// determine whether or not to display a stat
int EvaluateStatConditions(
	GAME * game,
	EXCELTABLE eDisplayTable, 
	int nDisplayArea,
	UNIT * unit,
	int * pnStatLines,
	STATS ** ppRiderStats,
	int nMaxStatLines,
	BOOL bPrintRider);

// determine whether or not to display a stats line
BOOL EvaluateDisplayCondition(
	GAME * game,
	EXCELTABLE eDisplayTable, 
	int nDisplayLine,
	DISPLAY_CONDITION_RESULTS * results,
	int count,
	UNIT * unit,
	STATS * rider);

#if ISVERSION(DEVELOPMENT)
void StatsVerifyNoSendStats(
	GAME * game,
	STATS * stats,
	const char * szStateName);
#endif

BOOL WriteStats(
	struct GAME * game,
	STATS * stats,
	BIT_BUF & buf,
	enum STATS_WRITE_METHOD eMethod);

BOOL ReadStats(
	struct GAME * game,
	STATS * stats,
	BIT_BUF & buf,
	enum STATS_WRITE_METHOD eMethod);

BOOL StatsTestFlag(
	const STATS * stats,
	int flag);

void StatsExitLimboCallback(
	struct GAME * game,
	struct UNIT * unit);

DWORD StatsListGetId(
	const STATS * stats);

void StatsListSetId(
	STATS * stats,
	DWORD dwId);

void UnitSetStatDelayedTimer(
	UNIT * unit,
	int wStat,
	PARAM dwParam,
	int value);

void StatsChangeStatSpecialFunctionSetRegenOnGetStat(
	GAME * game,
	UNIT * unit,
	int wStat,
	PARAM dwParam,
	const STATS_DATA * stats_data,
	int oldval,
	int newval,
	int max);

void GlobalStatsTrackerTrace(
	void);


//----------------------------------------------------------------------------
// ACCESSOR FUNCTIONS
//----------------------------------------------------------------------------
// return excel data for a stat
inline const STATS_DATA * StatsGetData(
	struct GAME * game,
	unsigned int stat)
{
	return (const STATS_DATA *)ExcelGetData(EXCEL_CONTEXT(game), DATATABLE_STATS, stat);
}

// return zero adjusted by offset
inline int StatsGetDefaultZeroValue(
	struct GAME * game,
	unsigned int stat)
{
	const STATS_DATA * stats_data = StatsGetData(game, stat);
	ASSERT_RETZERO(stats_data);
	return 0 - stats_data->m_nStatOffset;
}


// test a stats data flag
inline BOOL StatsDataTestFlag(
	const STATS_DATA * stats_data,
	unsigned int flag)
{
	return TESTBIT(stats_data->m_dwFlags, flag);
}


// return max stat for a stat
inline int StatsDataGetMaxStat(
	struct GAME * game,
	unsigned int stat)
{
	const STATS_DATA * stats_data = StatsGetData(game, stat);
	ASSERT_RETINVALID(stats_data);
	return stats_data->m_nMaxStat;
}

// return max value for a stat
inline int StatsDataGetMaxValue(
	struct GAME * game,
	unsigned int stat)
{
	const STATS_DATA * stats_data = StatsGetData(game, stat);
	ASSERT_RETZERO(stats_data);
	if (stats_data->m_nValBits > 0 && stats_data->m_nValTable >= 0)
	{
		return ExcelGetCount(EXCEL_CONTEXT(game), stats_data->m_nValTable);
	}
	else
	{
		return  (1 << stats_data->m_nValBitsFile ); 
	}
}


// return shift value for a stat
inline int StatsGetShift(
	GAME * game,
	unsigned int stat)
{
	const STATS_DATA * stats_data = (const STATS_DATA *)ExcelGetData(game, DATATABLE_STATS, stat);
	ASSERT_RETFALSE(stats_data);
	return stats_data->m_nShift;
}


// return total number of stats
inline int GetNumStats(
	struct GAME * game = NULL)
{
	return ExcelGetCount(EXCEL_CONTEXT(game), DATATABLE_STATS);
}


// return the associated stat for feed & requirements  (for level feed, this would be level)
inline int StatsGetAssociatedStat(
	const STATS_DATA * stats_data,
	unsigned int index)
{
	ASSERT_RETINVALID(stats_data);
	ASSERT_RETINVALID(index < STATS_NUM_ASSOCATED);
	return stats_data->m_nAssociatedStat[index];
}


// return the associated stat for feed & requirements  (for level feed, this would be level)
inline int StatsGetAssociatedStat(
	GAME * game,
	int stat,
	const STATS_DATA * stats_data = NULL)
{
	if (!stats_data)
	{
		stats_data = (const STATS_DATA *)ExcelGetData(game, DATATABLE_STATS, stat);
		ASSERT_RETINVALID(stats_data);
	}
	return stats_data->m_nAssociatedStat[0];
}


// return the number of "combat" stats
inline int StatsGetNumCombatStats(
	GAME * game)
{
	const STATS_DATAEX * stats_dataex = (const STATS_DATAEX *)ExcelGetDataEx(game, DATATABLE_STATS, 0);
	ASSERT_RETZERO(stats_dataex);
	return stats_dataex->m_nCombatStats;
}


// get a combat stat from the combat stat index
inline int StatsGetCombatStat(
	GAME * game,
	unsigned int index)
{
	const STATS_DATAEX * stats_dataex = (const STATS_DATAEX *)ExcelGetDataEx(game, DATATABLE_STATS, 0);
	ASSERT_RETINVALID(stats_dataex);
	ASSERT_RETINVALID(index < stats_dataex->m_nCombatStats);
	ASSERT_RETINVALID(stats_dataex->m_pnCombatStats);
	return stats_dataex->m_pnCombatStats[index];
}


// return the number of "feed" stats
inline int StatsGetNumFeedStats(
	GAME * game)
{
	const STATS_DATAEX * stats_dataex = (const STATS_DATAEX *)ExcelGetDataEx(game, DATATABLE_STATS, 0);
	ASSERT_RETZERO(stats_dataex);
	return stats_dataex->m_nFeedStats;
}


// get the feed stat from the feed stat index
inline int StatsGetFeedStat(
	GAME * game,
	unsigned int index)
{
	const STATS_DATAEX * stats_dataex = (const STATS_DATAEX *)ExcelGetDataEx(game, DATATABLE_STATS, 0);
	ASSERT_RETINVALID(stats_dataex);
	ASSERT_RETINVALID(index < stats_dataex->m_nFeedStats);
	ASSERT_RETINVALID(stats_dataex->m_pnFeedStats);
	return stats_dataex->m_pnFeedStats[index];
}


// get the number of "requirement" stats
inline int StatsGetNumReqStats(
	GAME * game)
{
	const STATS_DATAEX * stats_dataex = (const STATS_DATAEX *)ExcelGetDataEx(game, DATATABLE_STATS, 0);
	ASSERT_RETZERO(stats_dataex);
	return stats_dataex->m_nRequirementStats;
}


// get the requirement stat from the requirement stat index
inline int StatsGetReqStat(
	GAME * game,
	unsigned int index)
{
	const STATS_DATAEX* stats_dataex = (const STATS_DATAEX *)ExcelGetDataEx(game, DATATABLE_STATS, 0);
	ASSERT_RETINVALID(stats_dataex);
	ASSERT_RETINVALID(index < stats_dataex->m_nRequirementStats);
	ASSERT_RETINVALID(stats_dataex->m_pnRequirementStats);
	return stats_dataex->m_pnRequirementStats[index];
}


// get the number of "requirement limit" stats
inline int StatsGetNumReqLimitStats(
	GAME * game)
{
	const STATS_DATAEX * stats_dataex = (const STATS_DATAEX *)ExcelGetDataEx(game, DATATABLE_STATS, 0);
	ASSERT_RETZERO(stats_dataex);
	return stats_dataex->m_nRequirementLimitStats;
}


// get the requirement limit stat from the requirement limit stat index
inline int StatsGetReqLimitStat(
	GAME * game,
	unsigned int index)
{
	const STATS_DATAEX * stats_dataex = (const STATS_DATAEX *)ExcelGetDataEx(game, DATATABLE_STATS, 0);
	ASSERT_RETINVALID(stats_dataex);
	ASSERT_RETINVALID(index < stats_dataex->m_nRequirementLimitStats);
	ASSERT_RETINVALID(stats_dataex->m_pnRequirementLimitStats);
	return stats_dataex->m_pnRequirementLimitStats[index];
}


// return excel data for a stat function
inline const STATS_FUNCTION * StatsFuncGetData(
	GAME * game,
	unsigned int func)
{
	return (const STATS_FUNCTION *)ExcelGetData(game, DATATABLE_STATS_FUNC, func);
}

// return excel data for stats selector
inline const STATS_SELECTOR_DATA * StatsSelectorGetData(
	GAME * game,
	STATS_SELECTOR eSelector)
{
	return (const STATS_SELECTOR_DATA *)ExcelGetData(game, DATATABLE_STATS_SELECTOR, eSelector);
}
	
// create a param for a stat
// note: currently all of these are broken if param is allowed to be negative
inline PARAM StatParam(
	const STATS_DATA * stats_data,
	unsigned int param1)
{
#if ISVERSION(DEVELOPMENT)
	ASSERT_RETZERO(stats_data);
	ASSERT_RETZERO(stats_data->m_nParamCount >= 1);
	ASSERT(param1 == INVALID_ID || (param1 & stats_data->m_nParamGetMask[0]) == param1);
	return (param1 & stats_data->m_nParamGetMask[0]);
#else
	REF(stats_data);
	return STAT_GET_PARAM(param1);
#endif
}


// create a param for a stat
inline PARAM StatParam(
	unsigned int stat,
	unsigned int param1)
{
#if ISVERSION(DEVELOPMENT)
	return StatParam(StatsGetData(NULL, stat), param1);
#else
	REF(stat);
	return STAT_GET_PARAM(param1);
#endif
}


// cram 2 params
inline PARAM StatParam(
	const STATS_DATA * stats_data,
	unsigned int param1,
	unsigned int param2)
{
#if ISVERSION(DEVELOPMENT)
	ASSERT_RETZERO(stats_data);
	ASSERT_RETZERO(stats_data->m_nParamCount >= 2);
	ASSERT(param1 == INVALID_ID || (param1 & stats_data->m_nParamGetMask[0]) == param1);
	ASSERT(param2 == INVALID_ID || (param2 & stats_data->m_nParamGetMask[1]) == param2);
#endif
	return (param1 & stats_data->m_nParamGetMask[0]) + 
		((param2 & stats_data->m_nParamGetMask[1]) << stats_data->m_nParamGetShift[1]);
}


// cram 2 params
inline PARAM StatParam(
	unsigned int stat,
	unsigned int param1,
	unsigned int param2)
{
	return StatParam(StatsGetData(NULL, stat), param1, param2);
}


// cram 3 params
inline PARAM StatParam(
	const STATS_DATA * stats_data,
	unsigned int param1,
	unsigned int param2,
	unsigned int param3)
{
#if ISVERSION(DEVELOPMENT)
	ASSERT_RETZERO(stats_data);
	ASSERT_RETZERO(stats_data->m_nParamCount >= 3);
	ASSERT(param1 == INVALID_ID || (param1 & stats_data->m_nParamGetMask[0]) == param1);
	ASSERT(param2 == INVALID_ID || (param2 & stats_data->m_nParamGetMask[1]) == param2);
	ASSERT(param3 == INVALID_ID || (param3 & stats_data->m_nParamGetMask[2]) == param3);
#endif
	return (param1 & stats_data->m_nParamGetMask[0]) + 
		((param2 & stats_data->m_nParamGetMask[1]) << stats_data->m_nParamGetShift[1]) +
		((param3 & stats_data->m_nParamGetMask[2]) << stats_data->m_nParamGetShift[2]);
}


// cram 3 params
inline PARAM StatParam(
	unsigned int stat,
	unsigned int param1,
	unsigned int param2,
	unsigned int param3)
{
	return StatParam(StatsGetData(NULL, stat), param1, param2, param3);
}


// cram 4 params
inline PARAM StatParam(
	const STATS_DATA * stats_data,
	unsigned int param1,
	unsigned int param2,
	unsigned int param3,
	unsigned int param4)
{
#if ISVERSION(DEVELOPMENT)
	ASSERT_RETZERO(stats_data);
	ASSERT_RETZERO(stats_data->m_nParamCount >= 3);
	ASSERT(param1 == INVALID_ID || (param1 & stats_data->m_nParamGetMask[0]) == param1);
	ASSERT(param2 == INVALID_ID || (param2 & stats_data->m_nParamGetMask[1]) == param2);
	ASSERT(param3 == INVALID_ID || (param3 & stats_data->m_nParamGetMask[2]) == param3);
	ASSERT(param4 == INVALID_ID || (param4 & stats_data->m_nParamGetMask[3]) == param4);
#endif
	return (param1 & stats_data->m_nParamGetMask[0]) + 
		((param2 & stats_data->m_nParamGetMask[1]) << stats_data->m_nParamGetShift[1]) +
		((param3 & stats_data->m_nParamGetMask[2]) << stats_data->m_nParamGetShift[2]) +
		((param4 & stats_data->m_nParamGetMask[3]) << stats_data->m_nParamGetShift[3]);
}


// cram 4 params
inline PARAM StatParam(
	unsigned int stat,
	unsigned int param1,
	unsigned int param2,
	unsigned int param3,
	unsigned int param4)
{
	return StatParam(StatsGetData(NULL, stat), param1, param2, param3, param4);
}


inline unsigned int StatGetParam(
	const STATS_DATA * stats_data,
	DWORD statparam,
	unsigned int param_index)
{
	ASSERT_RETZERO(stats_data);
	ASSERT_RETZERO(param_index < stats_data->m_nParamCount);
	ASSERT_RETZERO(param_index < STATS_MAX_PARAMS);
	unsigned int param = ((statparam >> stats_data->m_nParamGetShift[param_index]) & stats_data->m_nParamGetMask[param_index]);

	if (param == stats_data->m_nParamGetMask[param_index])
	{
		return INVALID_ID;
	}
	return param;
}


inline unsigned int StatGetParam(
	unsigned int stat,
	DWORD statparam,
	unsigned int param_index)
{
	return StatGetParam(StatsGetData(NULL, stat), statparam, param_index);
}


inline unsigned int StatAddParam(
	const STATS_DATA * stats_data,
	DWORD statparam,
	unsigned int param_index,
	unsigned int param)
{
	ASSERT_RETVAL(stats_data, statparam);
	ASSERT_RETVAL(param_index < stats_data->m_nParamCount, statparam);
	ASSERT_RETVAL(param_index < STATS_MAX_PARAMS,statparam);
#if ISVERSION(DEVELOPMENT)
	ASSERT_RETVAL((param == INVALID_ID || (param & stats_data->m_nParamGetMask[param_index]) == param), statparam);
#endif
	// first clear the param bits out of statparam
	statparam &= ~(stats_data->m_nParamGetMask[param_index] << stats_data->m_nParamGetShift[param_index]);
	// then add in the new param bits
	statparam |= ((param & stats_data->m_nParamGetMask[param_index]) << stats_data->m_nParamGetShift[param_index]);

	return statparam;
}


inline unsigned int StatAddParam(
	unsigned int stat,
	DWORD statparam,
	unsigned int param_index,
	unsigned int param)
{
	return StatAddParam(StatsGetData(NULL, stat), statparam, param_index, param);
}


inline unsigned int StatMakeInvalidParam(
	const STATS_DATA * stats_data,
	unsigned int param_index)
{
	ASSERT_RETZERO(stats_data);
	ASSERT_RETZERO(param_index < stats_data->m_nParamCount);
	ASSERT_RETZERO(param_index < STATS_MAX_PARAMS);
	return (INVALID_ID & stats_data->m_nParamGetMask[param_index]);
}


inline unsigned int StatMakeInvalidParam(
	unsigned int stat,
	unsigned int param_index)
{
	return StatMakeInvalidParam(StatsGetData(NULL, stat), param_index);
}


// round a shifted stat to nearest value
inline int StatsRoundStat(
	GAME * game,
	unsigned int stat,
	int value)
{
	int shift = StatsGetShift(game, stat);
	value = value + (1 << shift) / 2;
	value = value & ~((1 << shift) - 1);
	return value;
}


// round a stat after computing a pct of the value
template<class T>
inline int StatsRoundStatPct(
	GAME * game,
	int stat,
	int value,
	T pct)
{
	int shift = StatsGetShift(game, stat);
	value = PCT_ROUND(value << shift, pct);
	value = value + (1 << shift) / 2;
	value = value & ~((1 << shift) - 1);
	return value;
}


// round a stat after computing a pct of the value
template<class T>
inline int StatsRoundUpStatPct(
	GAME * game,
	int stat,
	int value,
	T pct)
{
	int shift = StatsGetShift(game, stat);
	value = PCT_ROUNDUP(value << shift, pct);
	value = value + (1 << shift) / 2;
	value = value & ~((1 << shift) - 1);
	return value;
}

#endif // _STATS_H_
